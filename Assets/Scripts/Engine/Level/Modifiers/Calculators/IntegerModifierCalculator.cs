#nullable enable // autogenerated

using System.Collections.Generic;
using System.Linq;

namespace PVZEngine.Modifiers
{
    public abstract class IntegerModifierCalculator<T> : ModifierCalculator<T, IntegerModifier<T>>
    {
        public override T? CalculateGeneric(T? value, IEnumerable<ModifierContainerItem> modifiers)
        {
            if (modifiers.Count() == 0)
                return value;

            var grouped = modifiers.GroupBy(m => m.modifier?.Priority ?? 0).OrderBy(g => g.Key);
            foreach (var layerModifiers in grouped)
            {
                T? orValue = default;
                T? xorValue = default;
                T? andValue = GetDefaultAndValue();
                int shiftBits = 0;
                bool bitReverse = false;
                T? setValue = value;
                T? addValue = default;
                T multiple = GetDefaultMultiple();
                T multiply = GetDefaultMultiple();
                foreach (var modi in layerModifiers)
                {
                    var buff = modi.container;
                    if (modi.modifier is not IntegerModifier<T> modifier)
                        continue;
                    var modifierValue = modifier.GetModifierValueGeneric(buff);
                    switch (modifier.Operator)
                    {
                        case IntegerOperator.Set:
                            setValue = modifierValue;
                            break;
                        case IntegerOperator.Add:
                            addValue = AddValue(addValue, modifierValue);
                            break;
                        case IntegerOperator.AddMultiple:
                            multiple = AddValue(multiple, modifierValue);
                            break;
                        case IntegerOperator.Multiply:
                            multiply = MultiplyValue(multiply, modifierValue);
                            break;
                        case IntegerOperator.BitReverse:
                            bitReverse = !bitReverse;
                            break;
                        case IntegerOperator.BitOr:
                            orValue = OrValue(orValue, modifierValue);
                            break;
                        case IntegerOperator.BitXor:
                            xorValue = XorValue(xorValue, modifierValue);
                            break;
                        case IntegerOperator.BitAnd:
                            andValue = AndValue(andValue, modifierValue);
                            break;
                        case IntegerOperator.BitLeftShift:
                            shiftBits = LeftShiftBits(shiftBits, modifierValue);
                            break;
                        case IntegerOperator.BitRightShift:
                            shiftBits = RightShiftBits(shiftBits, modifierValue);
                            break;
                    }
                }
                value = setValue;
                value = OrValue(value, orValue);
                value = XorValue(value, xorValue);
                value = AndValue(value, andValue);
                value = ShiftValue(value, shiftBits);
                value = AddValue(value, addValue);
                value = MultiplyValue(value, multiple);
                value = MultiplyValue(value, multiply);
                if (bitReverse)
                {
                    value = ReverseValue(value);
                }
            }
            return value;
        }
        protected abstract T GetDefaultMultiple();
        protected abstract T GetDefaultAndValue();
        protected abstract T AddValue(T? value1, T? value2);
        protected abstract T MultiplyValue(T value1, T? value2);
        protected abstract T OrValue(T? value1, T? value2);
        protected abstract T XorValue(T? value1, T? value2);
        protected abstract T AndValue(T? value1, T? value2);
        protected abstract int LeftShiftBits(int bits, T? offset);
        protected abstract int RightShiftBits(int bits, T? offset);
        protected abstract T ShiftValue(T? value1, int bits);
        protected abstract T ReverseValue(T? value);
    }
    public class IntCalculator : IntegerModifierCalculator<int>
    {
        protected override int GetDefaultMultiple()
        {
            return 1;
        }

        protected override int AddValue(int value1, int value2)
        {
            return value1 + value2;
        }

        protected override int MultiplyValue(int value1, int value2)
        {
            return value1 * value2;
        }

        protected override int GetDefaultAndValue()
        {
            return ~0;
        }

        protected override int OrValue(int value1, int value2)
        {
            return value1 | value2;
        }

        protected override int XorValue(int value1, int value2)
        {
            return value1 ^ value2;
        }

        protected override int AndValue(int value1, int value2)
        {
            return value1 & value2;
        }

        protected override int LeftShiftBits(int bits, int offset)
        {
            return bits + offset;
        }

        protected override int RightShiftBits(int bits, int offset)
        {
            return bits - offset;
        }

        protected override int ShiftValue(int value1, int bits)
        {
            if (bits > 0)
            {
                return value1 << bits;
            }
            else if (bits < 0)
            {
                return value1 >> (-bits);
            }
            return value1;
        }

        protected override int ReverseValue(int value)
        {
            return ~value;
        }
    }
}
