#nullable enable // autogenerated

using Tools;
using Tools.Mathematics;
using UnityEngine;

namespace PVZEngine.Entities
{
    public abstract class Hitbox
    {
        public Hitbox(Entity entity)
        {
            Entity = entity;
        }
        public void ReevaluateBounds()
        {
            var scale = Entity.GetFinalScale();

            Vector3 size = GetSize();
            Vector3 offset = GetOffset();
            Vector3 pivot = GetPivot();

            var scaledSize = Vector3.Scale(size, scale);
            var scaledOffset = Vector3.Scale(offset, scale);
            var scaledPivot = Vector3.Scale(pivot, scale);

            cacheOffset = scaledOffset;

            var boundsCenter = cacheOffset + Vector3.Scale(Vector3.one * 0.5f - pivot, scaledSize);
            var boundsSize = scaledSize.Abs();
            cache = new Bounds(boundsCenter, boundsSize);
        }
        public bool IsInSphere(Vector3 center, float radius)
        {
            var bounds = GetBounds();
            return MathTool.CollideBetweenCubeAndSphere(bounds, center, radius);
        }
        public bool IsInCapsule(Vector3 pos1, Vector3 pos2, float radius)
        {
            var bounds = GetBounds();
            var capsule = new Capsule(pos1, pos2, radius);
            return MathTool.CollideBetweenCubeAndCapsule(capsule, bounds);
        }
        public Vector3 GetBoundsCenter()
        {
            return GetLocalCenter() + Entity.Position;
        }
        public Vector3 GetPosition()
        {
            return GetLocalOffset() + Entity.Position;
        }
        public Bounds GetBounds()
        {
            var bounds = GetLocalBounds();
            bounds.center += Entity.Position;
            return bounds;
        }
        public Vector3 GetBoundsSize()
        {
            return cache.size;
        }
        public Bounds GetLocalBounds()
        {
            return cache;
        }
        public Vector3 GetLocalCenter()
        {
            return cache.center;
        }
        public Vector3 GetLocalOffset()
        {
            return cacheOffset;
        }
        public bool Intersects(Hitbox other)
        {
            var bounds = GetBounds();
            var otherBounds = other.GetBounds();
            return bounds.IntersectsOptimized(otherBounds);
        }
        public bool DoCollision(Hitbox other, Vector3 offset, out Vector3 seperation)
        {
            var selfBounds = GetBounds();
            selfBounds.center += offset;
            var otherBounds = other.GetBounds();

            if (selfBounds.IntersectsOptimized(otherBounds))
            {
                seperation = otherBounds.center - selfBounds.center;
                return true;
            }
            seperation = Vector3.zero;
            return false;
        }
        public abstract Vector3 GetSize();
        public abstract Vector3 GetPivot();
        public abstract Vector3 GetOffset();
        public Entity Entity { get; }
        private Bounds cache;
        private Vector3 cacheOffset;
    }
}
