#nullable enable // autogenerated

using PVZEngine.Auras;
using PVZEngine.Buffs;
using PVZEngine.Level;
using PVZEngine.Modifiers;
using Tools;
using UnityEngine;

namespace PVZEngine.Entities
{
    public sealed partial class Entity : IAuraSource, IModifierContainer, IPropertyModifyTarget, ILevelSourceTarget, IModeledBuffTarget
    {
        #region 物理

        #region 体积
        public Vector3 GetCenter()
        {
            var center = Position;
            var pivot = Vector3.one * 0.5f - Cache.BoundsPivot;
            center += Vector3.Scale(GetScaledSize(), pivot);
            return center;
        }
        public Vector3 GetScaledSize()
        {
            var size = Cache.Size;
            size.Scale(Cache.GetFinalScale());
            return size.Abs();
        }
        public void SetCenter(Vector3 center)
        {
            var offset = GetCenter() - Position;
            Position = center - offset;
        }
        public Bounds GetBounds()
        {
            return new Bounds(GetCenter(), GetScaledSize());
        }
        #endregion

        public float GetGroundY()
        {
            return Level.GetGroundY(Position.x, Position.z);
        }
        public float GetRelativeY()
        {
            return Position.y - GetGroundY();
        }
        public void SetRelativeY(float value)
        {
            var pos = Position;
            pos.y = value + GetGroundY();
            Position = pos;
        }

        private Vector3 GetNextPosition(float simulationSpeed = 1)
        {
            Vector3 velocity = GetNextVelocity(simulationSpeed);
            velocity.Scale(Vector3.one - Cache.VelocityDampen);
            var nextPos = Position + velocity * simulationSpeed;
            return nextPos;
        }
        private Vector3 GetNextVelocity(float simulationSpeed = 1)
        {
            Vector3 velocity = Velocity;

            // Friction.
            var frictionMulti = Mathf.Pow(Mathf.Max(0, 1 - Cache.Friction), simulationSpeed);
            velocity = new Vector3(velocity.x * frictionMulti, velocity.y, velocity.z * frictionMulti);

            // Gravity.
            velocity.y -= Cache.Gravity * simulationSpeed;

            return velocity;
        }
        public void UpdatePhysics(float simulationSpeed = 1)
        {
            Vector3 nextVelocity = GetNextVelocity(simulationSpeed);
            Vector3 nextPos = GetNextPosition(simulationSpeed);

            // 地面限制。
            float groundY = Level.GetGroundY(nextPos.x, nextPos.z);
            var groundLimit = groundY + Cache.GroundLimitOffset;
            var contactingGround = nextPos.y <= groundY;
            var contactVelocity = nextVelocity;
            if (nextPos.y <= groundLimit)
            {
                nextPos.y = groundLimit;
                nextVelocity.y = Mathf.Max(nextVelocity.y, 0);
            }

            PreviousPosition = Position;
            Position = nextPos;
            Velocity = nextVelocity;

            if (contactingGround)
            {
                if (!IsOnGround)
                {
                    OnContactGround(contactVelocity);
                    IsOnGround = true;
                }
            }
            else
            {
                if (IsOnGround)
                {
                    OnLeaveGround();
                    IsOnGround = false;
                }
            }
        }
        #endregion

        #region 序列化
        private void LoadPhysicsFromSerializable(SerializableEntity seri)
        {
            PreviousPosition = seri.previousPosition;
            Position = seri.position;
            IsOnGround = seri.isOnGround;
            Velocity = seri.velocity;
        }
        #endregion

        #region 属性字段
        public Vector3 PreviousPosition { get; private set; }
        public Vector3 Position
        {
            get => _position;
            set
            {
                bool updates = _position != value;
                _position = value;
                if (updates)
                {
                    UpdateCollisionPosition();
                }
            }
        }
        public Vector3 Velocity { get; set; }
        public bool IsOnGround { get; private set; } = true;
        private Vector3 _position;
        #endregion
    }
}