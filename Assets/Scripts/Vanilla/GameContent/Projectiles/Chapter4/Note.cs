#nullable enable // autogenerated

using MVZ2.GameContent.Contraptions;
using MVZ2.Vanilla.Entities;
using MVZ2.Vanilla.Properties;
using PVZEngine.Callbacks;
using PVZEngine.Damages;
using PVZEngine.Entities;
using PVZEngine.Level;
using PVZEngine.Modifiers;
using UnityEngine;

namespace MVZ2.GameContent.Projectiles
{
    [EntityBehaviourDefinition(VanillaProjectileNames.note)]
    public class Note : ProjectileBehaviour
    {
        public Note(string nsp, string name) : base(nsp, name)
        {
            AddModifier(new Vector3Modifier(EngineEntityProps.DISPLAY_SCALE, NumberOperator.Multiply, PROP_DISPLAY_SCALE_MULTIPLIER));
            AddModifier(new Vector3Modifier(VanillaEntityProps.SHADOW_SCALE, NumberOperator.Multiply, PROP_DISPLAY_SCALE_MULTIPLIER));
            AddModifier(new FloatModifier(VanillaEntityProps.DAMAGE, NumberOperator.Multiply, PROP_DAMAGE_GROWTH));
        }
        public override void Init(Entity entity)
        {
            base.Init(entity);
            entity.CollisionMaskFriendly |= EntityCollisionHelper.MASK_PLANT;
            SetDamageGrowth(entity, MIN_GROWTH);
        }
        public override void Update(Entity projectile)
        {
            base.Update(projectile);
            var dmg = projectile.GetDamage();
            projectile.SetProperty(PROP_DISPLAY_SCALE_MULTIPLIER, Vector3.one * Mathf.Min(5, Mathf.Pow(dmg / 10f, 0.5f)));
            SetHitProtected(projectile, false);

            var growth = GetDamageGrowth(projectile);
            growth = Mathf.Clamp(Mathf.Lerp(growth, MAX_GROWTH, GROWTH_LERP_T), MIN_GROWTH, MAX_GROWTH);
            SetDamageGrowth(projectile, growth);
        }
        protected override void PreHitEntity(ProjectileHitInput hit, DamageInput damage, CallbackResult result)
        {
            base.PreHitEntity(hit, damage, result);
            if (IsHitProtected(hit.Projectile))
            {
                result.SetFinalValue(false);
            }
        }
        protected override void PostHitEntity(ProjectileHitOutput hitResult, DamageOutput? damage)
        {
            base.PostHitEntity(hitResult, damage);
            var note = hitResult.Projectile;
            Reflect(note, hitResult.Collider);

            SetHitProtected(note, true);
            SetNoteCharged(note, false);

            var dmg = note.GetDamage(true);
            dmg--;
            note.SetDamage(dmg);
            if (dmg <= 0)
            {
                note.Remove();
            }
        }
        public override void PostCollision(EntityCollision collision, int state)
        {
            base.PostCollision(collision, state);
            if (state == EntityCollisionHelper.STATE_EXIT)
                return;
            var note = collision.Entity;
            var noteBlock = collision.Other;
            if (!noteBlock.IsEntityOf(VanillaContraptionID.noteBlock))
                return;
            if (IsNoteCharged(note))
                return;
            if (!collision.OtherCollider.IsMainCollider())
                return;
            if (note.Parent != noteBlock || !note.IsFriendly(noteBlock))
                return;
            note.SetDamage(noteBlock.GetDamage());
            SetDamageGrowth(note, MIN_GROWTH);
            note.Velocity = noteBlock.GetFacingDirection() * noteBlock.GetShotVelocity().magnitude;
            SetNoteCharged(note, true);
            SetHitProtected(note, false);
            note.ClearIgnoredProjectileColliders();
            noteBlock.TriggerAnimation("Shoot");
            NoteBlock.PlayHarpSound(noteBlock);
        }
        public static void Reflect(Entity note, IEntityCollider other)
        {
            var vel = note.Velocity;
            var magnitude = vel.magnitude;
            var otherPosition = other.GetBoundingBox().center;
            if (vel.x > 0)
            {
                // 正在向右飞，只要撞到左侧就会反弹
                var minX = note.GetBounds().min.x;
                if (minX <= otherPosition.x)
                {
                    vel = Vector3.left * magnitude;
                }
            }
            else
            {
                // 正在向左飞，只要撞到右侧就会反弹
                var maxX = note.GetBounds().max.x;
                if (maxX >= otherPosition.x)
                {
                    vel = Vector3.right * magnitude;
                }
            }
            note.Velocity = vel;
        }
        public static void SetHitProtected(Entity note, bool value) => note.SetBehaviourField(PROP_HIT_PROTECTED, value);
        public static bool IsHitProtected(Entity note) => note.GetBehaviourField<bool>(PROP_HIT_PROTECTED);
        public static void SetNoteCharged(Entity note, bool value) => note.SetBehaviourField(PROP_NOTE_CHARGED, value);
        public static bool IsNoteCharged(Entity note) => note.GetBehaviourField<bool>(PROP_NOTE_CHARGED);
        public static void SetDamageGrowth(Entity note, float value) => note.SetBehaviourField(PROP_DAMAGE_GROWTH, value);
        public static float GetDamageGrowth(Entity note) => note.GetBehaviourField<float>(PROP_DAMAGE_GROWTH);

        public const float MIN_GROWTH = 0.1f;
        public const float MAX_GROWTH = 1;
        public const float GROWTH_LERP_T = 0.25f;

        private static readonly VanillaEntityPropertyMeta<Vector3> PROP_DISPLAY_SCALE_MULTIPLIER = new VanillaEntityPropertyMeta<Vector3>("DisplayScaleMultiplier");
        private static readonly VanillaEntityPropertyMeta<bool> PROP_HIT_PROTECTED = new VanillaEntityPropertyMeta<bool>("HitProtected");
        private static readonly VanillaEntityPropertyMeta<bool> PROP_NOTE_CHARGED = new VanillaEntityPropertyMeta<bool>("NoteCharged");
        private static readonly VanillaEntityPropertyMeta<float> PROP_DAMAGE_GROWTH = new VanillaEntityPropertyMeta<float>("DamageGrowth");
    }
}
