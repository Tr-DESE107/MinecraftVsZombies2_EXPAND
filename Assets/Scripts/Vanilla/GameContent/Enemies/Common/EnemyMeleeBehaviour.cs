#nullable enable // autogenerated

using System.Diagnostics.CodeAnalysis;
using MVZ2.GameContent.Damages;
using MVZ2.Vanilla.Callbacks;
using MVZ2.Vanilla.Contraptions;
using MVZ2.Vanilla.Detections;
using MVZ2.Vanilla.Entities;
using MVZ2.Vanilla.Properties;
using PVZEngine.Damages;
using PVZEngine.Entities;
using PVZEngine.Level;

namespace MVZ2.Vanilla.Enemies
{
    [EntityBehaviourDefinition(VanillaEntityBehaviourNames.enemyMelee)]
    public class EnemyMeleeBehaviour : AIEntityBehaviour
    {
        public EnemyMeleeBehaviour(string nsp, string name) : base(nsp, name)
        {
        }

        protected override void UpdateAI(Entity enemy)
        {
            var targetID = GetMeleeTarget(enemy);
            if (targetID != null && !ValidateMeleeTarget(enemy, targetID.GetEntity(enemy.Level)))
            {
                SetMeleeTarget(enemy, null);
            }
            base.UpdateAI(enemy);
        }
        public override void PostCollision(EntityCollision collision, int state)
        {
            if (!collision.Collider.IsForMain())
                return;
            if (!collision.OtherCollider.IsForMain())
                return;
            if (state != EntityCollisionHelper.STATE_EXIT)
            {
                MeleeCollision(collision.Entity, collision.Other);
            }
            else
            {
                CancelMeleeAttack(collision.Entity, collision.Other);
            }
        }
        private void MeleeCollision(Entity enemy, Entity other)
        {
            var targetID = GetMeleeTarget(enemy);
            var currentTarget = targetID?.GetEntity(enemy.Level);
            if (ValidateMeleeTarget(enemy, currentTarget))
                return;
            var target = other;
            var protector = target.GetProtector();
            if (protector != null && protector.Exists() && !protector.IsFriendly(enemy))
            {
                target = protector;
            }
            if (ValidateMeleeTarget(enemy, target))
            {
                SetMeleeTarget(enemy, new EntityID(target));
            }
        }
        private bool ValidateMeleeTarget(Entity enemy, [NotNullWhen(true)] Entity? target)
        {
            if (target == null || !target.Exists() || target.IsDead)
                return false;
            if (!enemy.IsHostile(target))
                return false;
            if (!Detection.IsInSameRow(enemy, target))
                return false;
            if (!Detection.CanDetect(target))
                return false;
            if (target.Position.y > enemy.Position.y + enemy.GetMaxAttackHeight())
                return false;
            if (target.Type == EntityTypes.PLANT || target.Type == EntityTypes.OBSTACLE)
            {
                if (target.IsFloor())
                    return false;
                var protector = target.GetProtector();
                if (protector != null && protector.Exists() && !protector.IsFriendly(enemy))
                    return false;
            }
            return true;
        }
        private void CancelMeleeAttack(Entity enemy, Entity other)
        {
            var meleeTarget = GetMeleeTarget(enemy);
            if (meleeTarget != null && meleeTarget.ID == other.ID)
            {
                SetMeleeTarget(enemy, null);
            }
        }
        public static bool CanMeleeAttack(Entity enemy)
        {
            var meleeTarget = GetMeleeTarget(enemy);
            return meleeTarget != null && meleeTarget.Exists(enemy.Level);
        }
        public static void MeleeAttack(Entity enemy)
        {
            var meleeTargetID = GetMeleeTarget(enemy);
            var meleeTarget = meleeTargetID?.GetEntity(enemy.Level);
            if (meleeTarget != null)
            {
                MeleeAttack(enemy, meleeTarget);
            }
        }
        public static void MeleeAttack(Entity enemy, Entity target)
        {
            var vel = enemy.Velocity;
            if (enemy.IsFacingLeft() == vel.x < 0)
            {
                vel.x *= 0.8f;
            }
            enemy.Velocity = vel;
            var damage = enemy.GetDamage() * enemy.GetAttackSpeed() / 30f;
            target.TakeDamage(damage, new DamageEffectList(VanillaDamageEffects.MUTE, VanillaDamageEffects.ENEMY_MELEE), enemy);
            enemy.Level.Triggers.RunCallback(VanillaLevelCallbacks.POST_ENEMY_MELEE_ATTACK, new VanillaLevelCallbacks.EnemyMeleeAttackParams(enemy, target, damage));
        }
        public static EntityID? GetMeleeTarget(Entity entity) => entity.GetProperty<EntityID>(PROP_MELEE_TARGET);
        public static void SetMeleeTarget(Entity entity, EntityID? value) => entity.SetProperty(PROP_MELEE_TARGET, value);
        public static readonly VanillaEntityPropertyMeta<EntityID> PROP_MELEE_TARGET = new VanillaEntityPropertyMeta<EntityID>("melee_target");
    }
}