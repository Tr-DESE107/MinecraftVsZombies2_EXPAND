#nullable enable // autogenerated

using MVZ2.GameContent.Detections;
using MVZ2.GameContent.Projectiles;
using MVZ2.Vanilla.Audios;
using MVZ2.Vanilla.Contraptions;
using MVZ2.Vanilla.Detections;
using MVZ2.Vanilla.Entities;
using MVZ2.Vanilla.Properties;
using MVZ2Logic.Level;
using PVZEngine;
using PVZEngine.Entities;
using PVZEngine.Level;
using Tools;
using UnityEngine;
using MVZ2.GameContent.Buffs;
using PVZEngine.Buffs;
using MVZ2.GameContent.Damages;
using PVZEngine.Damages;
using MVZ2.GameContent.Effects;
using MVZ2.Vanilla.Level;

namespace MVZ2.GameContent.Contraptions
{
    [EntityBehaviourDefinition(VanillaContraptionNames.Snipenser)]
    public class Snipenser : ContraptionBehaviour
    {
        public Snipenser(string nsp, string name) : base(nsp, name)
        {
            detector = new SnipenserDetector(ATTACK_HEIGHT);
        }
        public override void Init(Entity entity)
        {
            base.Init(entity);
            SetAttackTimer(entity, new FrameTimer(ATTACK_INTERVAL));
            SetEvocationTimer(entity, new FrameTimer(EVOKATION_TIMER));
        }
        protected override void OnEvoke(Entity entity)
        {
            base.OnEvoke(entity);
            var evokeTimer = GetEvocationTimer(entity);
            evokeTimer?.Reset();
            entity.SetEvoked(true);
            entity.PlaySound(VanillaSoundID.gunReload);
            entity.PlaySound(VanillaSoundID.fuse);
        }
        protected override void UpdateAI(Entity entity)
        {
            base.UpdateAI(entity);
            var shootTimer = GetAttackTimer(entity);
            if (!entity.IsEvoked())
            {
                if (shootTimer.RunToExpiredAndNotNull(entity.GetAttackSpeed()))
                {
                    var target = detector.DetectEntityWithTheMost(entity, t => GetTargetPriority(entity, t));
                    if (target != null)
                    {
                        // 计算直线方向和速度  
                        var direction = (target.GetCenter() - entity.GetShootPoint()).normalized;
                        var speed = entity.GetShotVelocity().magnitude * 1.5f;
                        var velocity = direction * speed;

                        Shoot(entity, entity.GetProjectileID() ?? VanillaProjectileID.fireCharge, entity.GetDamage(), velocity);
                    }
                    shootTimer.Reset();
                }
                return;
            }
            EvokedUpdate(entity);
        }
        private float GetTargetPriority(Entity self, Entity target)
        {
            var target2Self = target.Position - self.Position;
            target2Self.y = 0;
            var distance = target2Self.magnitude;
            var priority = -distance;
            if (target.Position.y > self.Position.y + 40)
            {
                priority += 300;
            }
            return priority;
        }
        public static void Shoot(Entity entity, NamespaceID projectileID, float damage, Vector3 velocity)
        {
            entity.TriggerAnimation("Shoot");
            var proID = projectileID;
            var BulletRNG = entity.RNG.Next(6);
            switch (BulletRNG)
            {
                case 0:
                    proID = VanillaProjectileID.SmallRocket;
                    break;
                case 1:
                    proID = VanillaProjectileID.RedKnife;
                    break;
                case 2:
                case 3:
                    proID = VanillaProjectileID.bullet;
                    break;
                default:
                    proID = VanillaProjectileID.arrow;
                    break;
            }

            var projectile = entity.ShootProjectile(new ShootParams()
            {
                projectileID = proID,
                position = entity.GetShootPoint(),
                faction = entity.GetFaction(),
                damage = damage,
                soundID = entity.GetShootSound(),
                velocity = velocity,
            })?.Let(e => e.SetGravity(0)); // 移除重力，使用直线飞行  
        }
        private void EvokedUpdate(Entity entity)
        {
            var evokeTimer = GetEvocationTimer(entity);
            var level = entity.Level;
            var grid = level.GetAllGrids().Random(entity.RNG);
            var targets = entity.Level.FindEntities(e => IsEvocationTarget(entity, e)).RandomTake(1, entity.RNG);
            var targetPos = grid.GetEntityPosition();
            int frames = Ticks.FromSeconds(1);
            foreach (var target in targets)
            {
                targetPos = target.GetCenter() + frames * target.Velocity;
            }
            var velocity = VanillaProjectileExt.GetLobVelocityByTime(entity.GetShootPoint(), targetPos, frames, 0);

            if (evokeTimer == null || evokeTimer.Expired)
            {
                entity.SetEvoked(false);
            }
            else
            {
                evokeTimer.Run();
                Explode(entity, 120, 1200);
                entity.Level.ShakeScreen(10, 0, 15);
                if (evokeTimer.PassedInterval(3))
                {
                    Shoot(entity, entity.GetProjectileID() ?? VanillaProjectileID.missile, entity.GetDamage(), velocity);
                }
                if (evokeTimer.PassedInterval(5))
                {
                    Shoot(entity, entity.GetProjectileID() ?? VanillaProjectileID.NightmareBall, entity.GetDamage(), velocity);
                }


            }
        }
        public static DamageOutput[] Explode(Entity entity, float range, float damage)
        {
            var damageEffects = new DamageEffectList(VanillaDamageEffects.MUTE, VanillaDamageEffects.DAMAGE_BODY_AFTER_ARMOR_BROKEN, VanillaDamageEffects.EXPLOSION);
            var damageOutputs = entity.Level.Explode(entity.Position, range, entity.GetFaction(), damage, damageEffects, entity);
            foreach (var output in damageOutputs)
            {
                var result = output.BodyResult;
                if (result != null && result.Fatal)
                {
                    var target = output.Entity;
                    var distance = (target.Position - entity.Position).magnitude;
                    var speed = 25 * Mathf.Lerp(1f, 0.5f, distance / range);
                    target.Velocity = target.Velocity + Vector3.up * speed;
                }
            }
            Explosion.Spawn(entity, entity.GetCenter(), range);
            entity.PlaySound(VanillaSoundID.explosion);
            entity.Level.ShakeScreen(10, 0, 15);


            return damageOutputs;
        }
        private static bool IsEvocationTarget(Entity self, Entity target)
        {
            if (target == null)
                return false;
            if (target.IsDead)
                return false;
            if (!target.IsVulnerableEntity())
                return false;
            if (!self.IsHostile(target))
                return false;
            if (!Detection.CanDetect(target))
                return false;
            return true;
        }
        public static FrameTimer? GetAttackTimer(Entity entity) => entity.GetBehaviourField<FrameTimer>(ID, PROP_ATTACK_TIMER);
        public static void SetAttackTimer(Entity entity, FrameTimer timer) => entity.SetBehaviourField(ID, PROP_ATTACK_TIMER, timer);
        public static FrameTimer? GetEvocationTimer(Entity entity) => entity.GetBehaviourField<FrameTimer>(ID, PROP_MISSLE_TIMEOUT);
        public static void SetEvocationTimer(Entity entity, FrameTimer timer) => entity.SetBehaviourField(ID, PROP_MISSLE_TIMEOUT, timer);

        public const float ATTACK_HEIGHT = 300;
        public const int ATTACK_INTERVAL = 60;
        public const int EVOKATION_TIMER = 45;
        public const int GRAVITY = 1;
        public static readonly VanillaEntityPropertyMeta<FrameTimer> PROP_ATTACK_TIMER = new VanillaEntityPropertyMeta<FrameTimer>("AttackTimer");
        public static readonly VanillaEntityPropertyMeta<FrameTimer> PROP_MISSLE_TIMEOUT = new VanillaEntityPropertyMeta<FrameTimer>("MissleTimeout");

        private Detector detector;
        private static readonly NamespaceID ID = VanillaContraptionID.Snipenser;
    }
}