#nullable enable // autogenerated

using System.Linq;
using MVZ2.GameContent.Buffs;
using MVZ2.GameContent.Buffs.Contraptions;
using MVZ2.GameContent.Damages;
using MVZ2.GameContent.Difficulties;
using MVZ2.Vanilla.Audios;
using MVZ2.Vanilla.Entities;
using PVZEngine;
using PVZEngine.Buffs;
using PVZEngine.Callbacks;
using PVZEngine.Damages;
using PVZEngine.Entities;
using PVZEngine.Level;

namespace MVZ2.GameContent.Contraptions
{
    [EntityBehaviourDefinition(VanillaContraptionNames.elasticCloud)]
    public class ElasticCloud : AIEntityBehaviour
    {
        public ElasticCloud(string nsp, string name) : base(nsp, name)
        {
        }
        public override void Init(Entity entity)
        {
            base.Init(entity);
            entity.CollisionMaskHostile |= EntityCollisionHelper.MASK_ENEMY;
        }
        public override void PostCollision(EntityCollision collision, int state)
        {
            base.PostCollision(collision, state);
            if (!collision.OtherCollider.IsForMain())
                return;
            var cloud = collision.Entity;
            var other = collision.Other;
            if (other.Type != EntityTypes.ENEMY || !cloud.IsHostile(other))
                return;
            TryBounceEnemy(cloud, other);
        }
        public override void PreTakeDamage(DamageInput input, CallbackResult result)
        {
            base.PreTakeDamage(input, result);
            bool punch = input.Effects.HasEffect(VanillaDamageEffects.IMPACT);
            if (input.Effects.HasEffect(VanillaDamageEffects.ENEMY_MELEE) || punch)
            {
                var cloud = input.Entity;
                if (input.Source is EntitySourceReference entityRef)
                {
                    TryBounceEnemy(cloud, entityRef.GetEntity(cloud.Level), punch);
                }
                result.SetFinalValue(false);
                return;
            }
        }
        public static bool TryBounceEnemy(Entity self, Entity? enemy, bool ignoreCooldown = false)
        {
            if (!enemy.ExistsAndAlive() || enemy.Type != EntityTypes.ENEMY)
                return false;
            if (!ignoreCooldown && HasEnemyKnockbackCooldown(self, enemy))
                return false;
            var knockbackMultiplier = enemy.GetStrongKnockbackMultiplier();
            enemy.Velocity += knockbackMultiplier * KNOCKBACK_DISTANCE * self.GetFacingDirection();

            var bounceDamage = BOUNCE_DAMAGE * self.Level.GetElasticCloudBounceDamageMultiplier();
            self.TakeDamage(bounceDamage, new DamageEffectList(VanillaDamageEffects.SELF_DAMAGE), self);
            AddEnemyKnockbackCooldown(self, enemy, Ticks.FromSeconds(KNOCKBACK_COOLDOWN_SECONDS));
            PlayBounceEffect(self);
            return true;
        }
        public static void PlayBounceEffect(Entity entity)
        {
            entity.TriggerAnimation("Bounce");
            entity.PlaySound(VanillaSoundID.boing);
        }
        public static void AddEnemyKnockbackCooldown(Entity self, Entity enemy, int cooldown)
        {
            var targetID = enemy.ID;
            var buffID = VanillaBuffID.Contraption.elasticCloudBounceCooldown;
            var buff = GetEnemyKnockbackCooldownBuff(self, enemy);
            if (buff == null)
            {
                buff = self.AddBuff(buffID);
                ElasticCloudBounceCooldownBuff.SetTargetID(buff, targetID);
            }
            ElasticCloudBounceCooldownBuff.SetTimeout(buff, cooldown);
        }
        public static Buff GetEnemyKnockbackCooldownBuff(Entity self, Entity enemy)
        {
            var targetID = enemy.ID;
            var buffID = VanillaBuffID.Contraption.elasticCloudBounceCooldown;
            var buffs = self.GetBuffs(buffID);
            return buffs.FirstOrDefault(b => ElasticCloudBounceCooldownBuff.GetTargetID(b) == targetID);
        }
        public static bool HasEnemyKnockbackCooldown(Entity self, Entity enemy)
        {
            return GetEnemyKnockbackCooldownBuff(self, enemy) != null;
        }
        public const float KNOCKBACK_DISTANCE = 20f;
        public const float BOUNCE_DAMAGE = 300f;
        public const float KNOCKBACK_COOLDOWN_SECONDS = 1f;
    }
}
