#nullable enable // autogenerated

using System;
using System.Collections.Generic;
using System.Linq;
using MVZ2.GameContent.Areas;
using MVZ2.GameContent.Armors;
using MVZ2.GameContent.Buffs;
using MVZ2.GameContent.Buffs.Carts;
using MVZ2.GameContent.Buffs.Contraptions;
using MVZ2.GameContent.Buffs.Enemies;
using MVZ2.GameContent.Damages;
using MVZ2.GameContent.Effects;
using MVZ2.GameContent.Pickups;
using MVZ2.GameContent.Seeds;
using MVZ2.Vanilla.Audios;
using MVZ2.Vanilla.Callbacks;
using MVZ2.Vanilla.Entities;
using MVZ2.Vanilla.Grids;
using MVZ2.Vanilla.Level;
using MVZ2.Vanilla.Properties;
using MVZ2.Vanilla.Shells;
using MVZ2Logic;
using MVZ2Logic.Level;
using PVZEngine;
using PVZEngine.Armors;
using PVZEngine.Base;
using PVZEngine.Buffs;
using PVZEngine.Callbacks;
using PVZEngine.Damages;
using PVZEngine.Entities;
using PVZEngine.Grids;
using PVZEngine.Level;
using Tools;
using UnityEditor;
using UnityEngine;
using GridLayerData = System.Tuple<PVZEngine.Grids.LawnGrid, PVZEngine.NamespaceID>;

namespace MVZ2.Vanilla.Entities
{
    public static class VanillaEntityExt
    {
        #region 面朝方向
        public static int GetFacingX(this Entity entity)
        {
            return entity.IsFacingLeft() ? -1 : 1;
        }
        public static Vector3 GetFacingDirection(this Entity entity)
        {
            return entity.IsFacingLeft() ? Vector3.left : Vector3.right;
        }
        #endregion

        #region 血量
        public static void SetModelDamagePercent(this Entity entity)
        {
            entity.SetModelDamagePercent(entity.Health, entity.GetMaxHealth());
        }
        public static void SetModelDamagePercent(this Entity entity, float health, float maxHealth)
        {
            entity.SetModelDamagePercent(1 - health / maxHealth);
        }
        public static void SetModelDamagePercent(this Entity entity, float percent)
        {
            entity.SetModelProperty("DamagePercent", percent);
        }
        #endregion

        #region 伤害
        public static void DamageBlink(this Entity entity)
        {
            if (entity != null && !entity.HasBuff<DamageColorBuff>())
                entity.AddBuff<DamageColorBuff>();
        }
        public static DamageOutput TakeDamageNoSource(this Entity entity, float amount, DamageEffectList effects, NamespaceID? armorSlot = null)
        {
            return entity.TakeDamageSourced(amount, effects, null, armorSlot);
        }
        public static DamageOutput TakeDamage(this Entity entity, float amount, DamageEffectList effects, Entity source, NamespaceID? armorSlot = null)
        {
            return entity.TakeDamageSourced(amount, effects, new EntitySourceReference(source), armorSlot);
        }
        public static DamageOutput TakeDamageSourced(this Entity entity, float amount, DamageEffectList effects, ILevelSourceReference? source, NamespaceID? armorSlot = null)
        {
            return TakeDamage(new DamageInput(amount, effects, entity, source, armorSlot));
        }
        public static DamageOutput TakeDamage(DamageInput input)
        {
            var result = new DamageOutput(input.Entity);
            if (input == null)
                return result;
            if (input.Entity.IsInvincible() || input.Entity.IsDead)
                return result;
            if (!PreTakeDamage(input, result))
                return result;
            if (!NamespaceID.IsValid(input.ShieldTarget))
            {
                var armor = input.Entity.GetMainArmor();
                if (Armor.Exists(armor) && !armor.IsIgnored() && !input.Effects.HasEffect(VanillaDamageEffects.IGNORE_ARMOR))
                {
                    ArmoredTakeDamage(armor, input, result);
                }
                else
                {
                    result.BodyResult = BodyTakeDamage(input);
                }
            }
            else
            {
                var armor = input.Entity.GetArmorAtSlot(input.ShieldTarget);
                if (Armor.Exists(armor) && !armor.IsIgnored())
                {
                    result.ShieldResult = armor.TakeDamage(input);
                    result.ShieldTarget = input.ShieldTarget;
                }
            }
            ApplyDamageSpecialEffects(result);
            if (result.IsValid())
            {
                PostTakeDamage(result);
            }
            return result;
        }


        private static bool PreTakeDamage(DamageInput damageInfo, DamageOutput output)
        {
            Entity entity = damageInfo.Entity;
            if (entity == null)
                return false;
            var result = new CallbackResult(true);
            entity.Definition.PreTakeDamage(damageInfo, result);
            if (!result.IsBreakRequested)
            {
                var param = new VanillaLevelCallbacks.PreTakeDamageParams(damageInfo, output);
                damageInfo.Entity.Level.Triggers.RunCallbackWithResultFiltered(VanillaLevelCallbacks.PRE_ENTITY_TAKE_DAMAGE, param, result, entity.Type);
            }
            return result.GetValue<bool>();
        }
        private static void ApplyDamageSpecialEffects(DamageOutput output)
        {
            Entity entity = output.Entity;
            if (entity == null)
                return;
            var param = new VanillaLevelCallbacks.PostTakeDamageParams(output);
            entity.Level.Triggers.RunCallbackFiltered(VanillaLevelCallbacks.APPLY_DAMAGE_SPECIAL_EFFECTS, param, entity.Type);
        }
        private static void PostTakeDamage(DamageOutput output)
        {
            Entity entity = output.Entity;
            if (entity == null)
                return;
            entity.Definition.PostTakeDamage(output);
            var param = new VanillaLevelCallbacks.PostTakeDamageParams(output);
            entity.Level.Triggers.RunCallbackFiltered(VanillaLevelCallbacks.POST_ENTITY_TAKE_DAMAGE, param, entity.Type);
        }
        private static void ArmoredTakeDamage(Armor armor, DamageInput info, DamageOutput result)
        {
            var entity = info.Entity;
            var armorResult = armor.TakeDamage(info);
            result.ArmorResult = armorResult;

            if (info.HasEffect(VanillaDamageEffects.DAMAGE_BOTH_ARMOR_AND_BODY))
            {
                result.BodyResult = BodyTakeDamage(info);
                return;
            }

            if (info.HasEffect(VanillaDamageEffects.DAMAGE_BODY_AFTER_ARMOR_BROKEN) && !Armor.Exists(entity.GetMainArmor()))
            {
                var armorSpendAmount = armorResult?.SpendAmount ?? 0;
                float overkillDamage = info.Amount - armorSpendAmount;
                if (overkillDamage > 0)
                {
                    var overkillInfo = new DamageInput(overkillDamage, info.Effects, entity, info.Source);
                    result.BodyResult = BodyTakeDamage(overkillInfo);
                }
                return;
            }
        }


        private static int PreBodyTakeDamage(this Entity armor, DamageInput input, BodyDamageResult result)
        {
            var callbackResult = new CallbackResult(DamageStates.CONTINUE);
            if (!callbackResult.IsBreakRequested)
            {
                var param = new VanillaLevelCallbacks.PreBodyTakeDamageParams(input, result);
                input.Entity.Level.Triggers.RunCallbackWithResultFiltered(VanillaLevelCallbacks.PRE_BODY_TAKE_DAMAGE, param, callbackResult, armor.Definition.GetID());
            }
            return callbackResult.GetValue<int>();
        }
        private static void PostBodyTakeDamage(this Entity entity, BodyDamageResult result)
        {
            var param = new VanillaLevelCallbacks.PostBodyTakeDamageParams(result);
            entity.Level.Triggers.RunCallbackFiltered(VanillaLevelCallbacks.POST_BODY_TAKE_DAMAGE, param, entity.Definition.GetID());
        }
        private static BodyDamageResult? BodyTakeDamage(DamageInput info)
        {
            var entity = info.Entity;
            var shell = entity.GetShellDefinition();

            var result = new BodyDamageResult(info, shell);

            var damageState = entity.PreBodyTakeDamage(info, result);
            if (damageState == DamageStates.BREAK)
            {
                return null;
            }
            else if (damageState == DamageStates.RETURN)
            {
                return result;
            }

            shell?.EvaluateDamage(info);

            // Apply Damage.
            var amount = info.Amount;
            if (amount > 0)
            {
                float hpBefore = entity.Health;
                entity.Health -= amount;

                result.Amount = amount;
                result.SpendAmount = Mathf.Min(hpBefore, amount);
                result.Fatal = hpBefore > 0 && entity.Health <= 0;
            }

            if (entity.Health <= 0)
            {
                entity.Die(info.Effects, info.Source, result);
            }
            if (result.IsValid())
            {
                PostBodyTakeDamage(entity, result);
            }

            return result;
        }
        #endregion

        #region 投射物
        public static Vector3 ModifyProjectileVelocity(this Entity entity, Vector3 velocity)
        {
            return velocity;
        }
        #endregion

        #region 光照
        public static bool IsIlluminated(this Entity entity)
        {
            return entity.Level.IsIlluminated(entity);
        }
        public static Entity? GetIlluminationLightSource(this Entity entity)
        {
            var level = entity.Level;
            var entityID = level.GetIlluminationLightSourceID(entity);
            return level.FindEntityByID(entityID);
        }
        public static Entity[] GetIlluminationLightSources(this Entity entity)
        {
            var level = entity.Level;
            var entitiesID = level.GetIlluminationLightSources(entity);
            return entitiesID.Select(e => level.FindEntityByID(e)).OfType<Entity>().ToArray();
        }
        #endregion

        #region 特效
        public static void UpdateShineRing(this Entity entity)
        {
            var lightSource = entity.IsLightSource();
            if (!lightSource)
                return;
            var shineRingID = entity.GetProperty<EntityID>(PROP_SHINE_RING);
            var shineRing = shineRingID?.GetEntity(entity.Level);
            if (shineRing != null && shineRing.Exists())
                return;
            shineRing = entity.Level.FindFirstEntity(e => e.IsEntityOf(VanillaEffectID.shineRing) && e.Parent == entity);
            if (shineRing == null || !shineRing.Exists())
            {
                shineRing = entity.Level.Spawn(VanillaEffectID.shineRing, entity.Position, entity)?.Let(e =>
                {
                    e.SetParent(entity);
                    entity.SetProperty(PROP_SHINE_RING, new EntityID(e));
                });
            }
        }
        #endregion

        #region 爆炸和溅射
        public static DamageOutput[] Explode(this Entity entity, Vector3 center, float radius, int faction, float amount, DamageEffectList effects, Predicate<IEntityCollider>? filter = null)
        {
            return entity.Level.Explode(center, radius, faction, amount, effects, entity, filter);
        }
        public static DamageOutput[] ExplodeAgainstFriendly(this Entity entity, Vector3 center, float radius, int faction, float amount, DamageEffectList effects)
        {
            return entity.Level.ExplodeAgainstFriendly(center, radius, faction, amount, effects, entity);
        }
        public static DamageOutput[] SplashDamage(this Entity entity, IEntityCollider excludeCollider, Vector3 center, float radius, int faction, float amount, DamageEffectList effects)
        {
            return entity.Level.SplashDamage(excludeCollider, center, radius, faction, amount, effects, entity);
        }
        #endregion

        #region 音效

        public static void PlayCrySound(this Entity entity, NamespaceID soundID, float pitchMultiplier = 1, float volume = 1)
        {
            var pitch = entity.GetCryPitch() * pitchMultiplier;
            entity.PlaySound(soundID, pitch, volume);
        }
        public static void PlaySound(this Entity entity, NamespaceID soundID, float pitch = 1, float volume = 1)
        {
            entity.Level.PlaySound(soundID, entity.Position, pitch, volume);
        }
        public static void PlaySoundIfNotNull(this Entity entity, NamespaceID? soundID, float pitch = 1, float volume = 1)
        {
            if (soundID == null)
                return;
            entity.PlaySound(soundID, pitch, volume);
        }
        public static void PlayHitSound(this DamageOutput damage)
        {
            if (damage == null)
                return;
            var entity = damage.Entity;

            var shieldResult = damage.ShieldResult;
            if (shieldResult != null)
                PlayArmorHitSound(entity, shieldResult);

            var armorResult = damage.ArmorResult;
            if (armorResult != null)
                PlayArmorHitSound(entity, armorResult);

            var bodyResult = damage.BodyResult;
            if (bodyResult != null && !bodyResult.Effects.HasEffect(VanillaDamageEffects.MUTE))
            {
                var shell = bodyResult.ShellDefinition;
                NamespaceID? hitSound = null;
                if (shell != null && shell.GetSpecialShellHitSound(bodyResult, false) is NamespaceID specialSound && NamespaceID.IsValid(specialSound))
                {
                    hitSound = specialSound;
                }
                else if (entity.GetHitSound() is NamespaceID specificSound && NamespaceID.IsValid(specificSound))
                {
                    hitSound = specificSound;
                }
                else if (shell != null && shell.GetHitSound() is NamespaceID shellSound && NamespaceID.IsValid(shellSound))
                {
                    hitSound = shellSound;
                }
                if (NamespaceID.IsValid(hitSound))
                {
                    entity.PlaySound(hitSound);
                }
            }
        }
        public static void PlayArmorHitSound(this Entity entity, ArmorDamageResult result)
        {
            if (!result.Effects.HasEffect(VanillaDamageEffects.MUTE))
            {
                var armor = result.Armor;
                var shell = result.ShellDefinition;
                NamespaceID? hitSound = null;
                if (shell != null && shell.GetSpecialShellHitSound(result, true) is NamespaceID specialSound && NamespaceID.IsValid(specialSound))
                {
                    hitSound = specialSound;
                }
                else if (armor.GetHitSound() is NamespaceID specificSound && NamespaceID.IsValid(specificSound))
                {
                    hitSound = specificSound;
                }
                else if (shell != null && shell.GetHitSound() is NamespaceID shellSound && NamespaceID.IsValid(shellSound))
                {
                    hitSound = shellSound;
                }
                if (NamespaceID.IsValid(hitSound))
                {
                    entity.PlaySound(hitSound);
                }
            }
        }
        public static NamespaceID? GetSpecialShellHitSound(this ShellDefinition shell, DamageResult result, bool isArmor)
        {
            var damageEffects = result.Effects;
            if (!isArmor)
            {
                if (damageEffects.HasEffect(VanillaDamageEffects.WHACK))
                {
                    return VanillaSoundID.bonk;
                }
                else if (damageEffects.HasEffect(VanillaDamageEffects.FALL_DAMAGE))
                {
                    return result.Amount > 100 ? VanillaSoundID.fallBig : VanillaSoundID.fallSmall;
                }
            }

            if (damageEffects.HasEffect(VanillaDamageEffects.FIRE) && !shell.BlocksFire())
            {
                return VanillaSoundID.fire;
            }
            else if (damageEffects.HasEffect(VanillaDamageEffects.SLICE) && shell.IsSliceCritical())
            {
                return VanillaSoundID.slice;
            }
            else if (damageEffects.HasEffect(VanillaDamageEffects.TINY))
            {
                return VanillaSoundID.smallHit;
            }
            else if (damageEffects.HasEffect(VanillaDamageEffects.LIGHTNING))
            {
                return VanillaSoundID.zap;
            }
            return null;
        }
        public static void EmitBlood(this Entity entity)
        {
            entity.Level.Spawn(VanillaEffectID.bloodParticles, entity.GetCenter(), entity)?.Let(e =>
            {
                var bloodColor = entity.GetBloodColor();
                e.SetTint(bloodColor);
            });
        }
        #endregion

        #region 换行
        public static void RandomChangeAdjacentLane(this Entity entity, RandomGenerator rng)
        {
            var lane = entity.GetLane();
            int laneDir;
            if (lane <= 0)
            {
                laneDir = 1;
            }
            else if (lane >= entity.Level.GetMaxLaneCount() - 1)
            {
                laneDir = -1;
            }
            else
            {
                laneDir = rng.Next(2) * 2 - 1;
            }
            var targetLane = lane + laneDir;
            entity.StartChangingLane(targetLane);
        }
        public static bool IsChangingLane(this Entity entity)
        {
            return entity.HasBuff<ChangeLaneBuff>();
        }
        public static void StartChangingLane(this Entity entity, int target)
        {
            var level = entity.Level;
            target = Math.Clamp(target, 0, level.GetMaxLaneCount() - 1);
            var source = entity.GetLane();
            var buff = entity.GetFirstBuff<ChangeLaneBuff>();
            if (buff == null)
            {
                buff = entity.AddBuff<ChangeLaneBuff>();
            }
            ChangeLaneBuff.Start(buff, target, source);
        }
        public static void StopChangingLane(this Entity entity)
        {
            var buff = entity.GetFirstBuff<ChangeLaneBuff>();
            if (buff == null)
            {
                return;
            }
            ChangeLaneBuff.Stop(buff);
        }
        #endregion

        #region 换格
        public static void StartChangingGrid(this Entity entity, int column, int lane)
        {
            var buff = entity.GetFirstBuff<ChangeGridBuff>();
            if (buff == null)
            {
                buff = entity.AddBuff<ChangeGridBuff>();
            }
            var level = entity.Level;
            column = Math.Clamp(column, 0, level.GetMaxColumnCount() - 1);
            lane = Math.Clamp(lane, 0, level.GetMaxLaneCount() - 1);
            ChangeGridBuff.Start(buff, column, lane);
        }
        public static void StopChangingGrid(this Entity entity)
        {
            var buff = entity.GetFirstBuff<ChangeGridBuff>();
            if (buff == null)
                return;
            ChangeGridBuff.Stop(buff);
        }
        #endregion
        public static bool IsVulnerableEntity(this Entity entity)
        {
            return entity.Type == EntityTypes.PLANT || entity.Type == EntityTypes.ENEMY || entity.Type == EntityTypes.OBSTACLE || entity.Type == EntityTypes.BOSS;
        }
        public static bool IsAliveEnemy(this Entity entity)
        {
            if (entity.Type != EntityTypes.ENEMY)
                return false;
            if (entity.IsDead && !entity.AssumeAlive())
                return false;
            if (entity.IsNotActiveEnemy())
                return false;
            if (!entity.IsHostile(entity.Level.Option.LeftFaction))
                return false;
            return true;
        }
        public static bool CanEntityEnterHouse(this Entity entity)
        {
            return entity.Type == EntityTypes.ENEMY && !entity.IsDead && !entity.IsHarmless() && entity.IsHostile(entity.Level.Option.LeftFaction);
        }
        public static bool IsFriendlyEntity(this Entity entity)
        {
            return entity.Level.IsFriendlyFaction(entity.GetFaction());
        }
        public static bool IsHostileEntity(this Entity entity)
        {
            return entity.Level.IsHostileFaction(entity.GetFaction());
        }
        public static bool IsFriendlyFaction(this LevelEngine level, int faction)
        {
            return EngineEntityExt.IsFriendly(faction, level.Option.LeftFaction);
        }
        public static bool IsHostileFaction(this LevelEngine level, int faction)
        {
            return !IsFriendlyFaction(level, faction);
        }
        public static EntitySeed? GetEntitySeedDefinition(this Entity entity)
        {
            var game = Global.Game;
            var seedDef = game.GetSeedDefinition(entity.GetDefinitionID());
            return seedDef as EntitySeed;
        }
        public static void Stun(this Entity entity, int timeout)
        {
            if (entity == null)
                return;
            var buff = entity.GetFirstBuff<StunBuff>();
            if (buff == null)
            {
                buff = entity.AddBuff<StunBuff>();
            }
            StunBuff.SetStunTime(buff, timeout);
        }

        #region 阻挡火焰
        public static bool WillDamageBlockFire(this DamageOutput damage)
        {
            if (damage == null)
                return false;
            foreach (var result in damage.GetAllResults())
            {
                if (result == null)
                    continue;
                var shell = result.ShellDefinition;
                if (shell == null)
                    continue;
                if (shell.BlocksFire())
                {
                    return true;
                }
            }
            return false;
        }
        #endregion


        #region 网格
        public static void UpdateTakenGrids(this Entity entity)
        {
            targetGridLayerDataBuffer.Clear();
            takenGridLayerDataBuffer.Clear();
            GetTargetGridLayersToTakeNonAlloc(entity, targetGridLayerDataBuffer);
            GetCurrentGridLayersToTakeNonAlloc(entity, takenGridLayerDataBuffer);
            entityGridUpdater.Update(targetGridLayerDataBuffer, takenGridLayerDataBuffer, g => entity.TakeGrid(g.Item1, g.Item2), g => entity.ReleaseGrid(g.Item1, g.Item2));
        }
        public static void DestroyConflictGridEntities(this Entity entity)
        {
            entity.UpdateTakenGrids();

            var grids = entity.GetGridsToTake();
            foreach (var grid in grids)
            {
                var takenLayers = entity.GetGridLayersToTake();
                if (takenLayers != null)
                {
                    entity.DestroyConflictGridEntities(grid, takenLayers);
                }
            }
        }
        public static void DestroyConflictGridEntities(this Entity entity, LawnGrid grid, NamespaceID[] layers)
        {
            // 找到目标地格上冲突的实体。
            var conflictEntities = new HashSet<Entity>();
            foreach (var layer in layers)
            {
                var layerEntities = grid.GetLayerEntities(layer);
                foreach (var ent in layerEntities)
                {
                    if (ent == entity)
                        continue;
                    conflictEntities.Add(ent);
                }
            }
            // 如果目标地格有冲突的实体，秒杀冲突的实体。
            foreach (var conflict in conflictEntities)
            {
                conflict.Die(entity);
            }
        }
        private static void GetTargetGridLayersToTakeNonAlloc(Entity entity, List<GridLayerData> buffer)
        {
            if (!entity.ExistsAndAlive())
                return;

            var grids = entity.GetGridsToTake();
            if (grids == null)
                return;

            var layers = entity.GetGridLayersToTake();
            if (layers == null)
                return;

            foreach (var grid in grids)
            {
                if (!CanTakeGrid(entity, grid))
                    continue;
                foreach (var layer in layers)
                {
                    buffer.Add(new GridLayerData(grid, layer));
                }
            }
        }
        private static void GetCurrentGridLayersToTakeNonAlloc(Entity entity, List<GridLayerData> buffer)
        {
            takenGridBuffer.Clear();
            entity.GetTakenGridsNonAlloc(takenGridBuffer);

            foreach (var grid in takenGridBuffer)
            {
                takenGridLayersBuffer.Clear();
                entity.GetTakingGridLayersNonAlloc(grid, takenGridLayersBuffer);

                foreach (var layer in takenGridLayersBuffer)
                {
                    buffer.Add(new GridLayerData(grid, layer));
                }
            }
        }
        private static bool CanTakeGrid(this Entity entity, LawnGrid grid)
        {
            if (grid == null)
                return false;
            if (!entity.ExistsAndAlive())
                return false;
            if (entity.GetRelativeY() > leaveGridHeight)
                return false;
            return true;
        }
        private const float leaveGridHeight = 64;
        private static ListUpdater<GridLayerData> entityGridUpdater = new ListUpdater<GridLayerData>();
        private static List<GridLayerData> targetGridLayerDataBuffer = new List<GridLayerData>();
        private static List<GridLayerData> takenGridLayerDataBuffer = new List<GridLayerData>();
        private static List<LawnGrid> takenGridBuffer = new List<LawnGrid>();
        private static List<NamespaceID> takenGridLayersBuffer = new List<NamespaceID>();
        #endregion


        #region 治疗
        public static HealOutput? HealEffects(this Entity entity, float amount, Entity? source)
        {
            return entity.HealEffectsSourced(amount, source == null ? null : new EntitySourceReference(source));
        }
        public static HealOutput? HealEffectsSourced(this Entity entity, float amount, ILevelSourceReference? source)
        {
            var result = entity.HealSourced(amount, source);
            if (result == null)
                return null;
            if (result.RealAmount >= 0)
            {
                entity.AddTickHealing(result.RealAmount);
            }
            return result;
        }

        public static HealOutput? Heal(this Entity entity, float amount, Entity? source)
        {
            return entity.HealSourced(amount, source == null ? null : new EntitySourceReference(source));
        }
        public static HealOutput? HealSourced(this Entity entity, float amount, ILevelSourceReference? source)
        {
            return Heal(new HealInput(amount, entity, source));
        }
        public static HealOutput? Heal(HealInput info)
        {
            if (info.Entity.IsDead)
                return null;
            if (!PreHeal(info))
                return null;
            if (info.Amount <= 0)
                return null;
            HealOutput result;
            if (info.ToArmor && info.Armor != null)
            {
                result = ArmorHeal(info.Armor, info);
            }
            else
            {
                result = BodyHeal(info);
            }
            PostHeal(result);
            return result;
        }
        private static bool PreHeal(HealInput info)
        {
            var entity = info.Entity;
            if (entity == null)
                return false;
            var result = new CallbackResult(true);
            var param = new VanillaLevelCallbacks.PreHealParams()
            {
                input = info
            };
            entity.Level.Triggers.RunCallbackWithResult(VanillaLevelCallbacks.PRE_ENTITY_HEAL, param, result);
            return result.GetValue<bool>();
        }
        private static void PostHeal(HealOutput output)
        {
            var entity = output.Entity;
            if (entity == null)
                return;
            var param = new VanillaLevelCallbacks.PostHealParams()
            {
                output = output
            };
            entity.Level.Triggers.RunCallback(VanillaLevelCallbacks.POST_ENTITY_HEAL, param);
        }
        private static HealOutput ArmorHeal(Armor armor, HealInput info)
        {
            // Apply Healing.
            float hpBefore = armor.Health;
            var maxHealth = armor.GetMaxHealth();
            if (armor.Health < maxHealth)
            {
                armor.Health = Mathf.Min(armor.Health + info.Amount, maxHealth);
            }

            return new HealOutput(armor.Owner, info.Source)
            {
                OriginalAmount = info.OriginalAmount,
                Amount = info.Amount,
                RealAmount = armor.Health - hpBefore,
                Armor = armor,
                ToArmor = true,
            };
        }
        private static HealOutput BodyHeal(HealInput info)
        {
            var entity = info.Entity;

            // Apply Healing.
            float hpBefore = entity.Health;
            var maxHealth = entity.GetMaxHealth();
            if (entity.Health < maxHealth)
            {
                entity.Health = Mathf.Min(entity.Health + info.Amount, maxHealth);
            }

            return new HealOutput(entity, info.Source)
            {
                OriginalAmount = info.OriginalAmount,
                Amount = info.Amount,
                RealAmount = entity.Health - hpBefore,
            };
        }
        #endregion

        #region 沉没
        public const int SPLASH_SIZE_UNIT = 110592; //48^3
        public static bool IsOnWater(this Entity entity)
        {
            var grid = entity.GetGrid();
            return grid != null && grid.IsWater();
        }
        public static bool IsInWater(this Entity entity)
        {
            return entity.IsOnWater() && entity.IsOnGround;
        }
        public static bool IsAboveCloud(this Entity entity)
        {
            var grid = entity.GetGrid();
            if (grid != null && grid.IsCloud())
                return true;
            if (entity.Level.AreaID == VanillaAreaID.ship)
            {
                var column = entity.GetColumn();
                var lane = entity.GetLane();
                if (column >= 0 && column < entity.Level.GetMaxColumnCount() && (lane < 0 || lane >= entity.Level.GetMaxLaneCount()))
                {
                    return true;
                }
            }
            return false;
        }
        public static bool IsInCloud(this Entity entity)
        {
            return entity.IsAboveCloud() && entity.IsOnGround;
        }
        public static bool IsAboveLand(this Entity entity)
        {
            var grid = entity.GetGrid();
            return grid == null || (!grid.IsWater() && !grid.IsCloud());
        }
        public static void PlaySplashEffect(this Entity entity)
        {
            var size = entity.GetScaledSize();
            var scale = Mathf.Clamp(size.x * size.y * size.z / SPLASH_SIZE_UNIT, 1, 5);
            entity.PlaySplashEffect(scale * Vector3.one);
        }
        public static void PlaySplashEffect(this Entity entity, Vector3 scale)
        {
            var level = entity.Level;
            entity.PlaySplashEffect(scale, level.GetWaterColor());
        }
        public static void PlayAirSplashEffect(this Entity entity)
        {
            var size = entity.GetScaledSize();
            var scale = Mathf.Clamp(size.x * size.y * size.z / SPLASH_SIZE_UNIT, 1, 5);
            entity.PlayAirSplashEffect(scale * Vector3.one);
        }
        public static void PlayAirSplashEffect(this Entity entity, Vector3 scale)
        {
            entity.PlaySplashEffect(scale, new Color(1, 1, 1, 0.5f));
        }
        public static void PlaySplashEffect(this Entity entity, Vector3 scale, Color color)
        {
            var level = entity.Level;
            var pos = entity.Position;
            pos.y = entity.GetGroundY();
            level.Spawn(VanillaEffectID.splashParticles, pos, entity)?.Let(e =>
            {
                e.SetTint(color);
                e.SetDisplayScale(scale);
            });
        }

        public static void PlayAirSplashSound(this Entity entity)
        {
            var sound = VanillaSoundID.cloth;
            entity.PlaySound(sound);
        }
        public static void PlaySplashSound(this Entity entity)
        {
            var level = entity.Level;
            var size = entity.GetScaledSize();
            var sound = VanillaSoundID.splash;
            if (entity.Type == EntityTypes.ENEMY)
            {
                sound = VanillaSoundID.water;
            }
            if (size.x * size.y * size.z / SPLASH_SIZE_UNIT > 1)
            {
                sound = VanillaSoundID.splashBig;
            }
            entity.PlaySound(sound);
        }
        #endregion

        #region 护甲
        public static Armor? GetMainArmor(this Entity entity)
        {
            return entity.GetArmorAtSlot(VanillaArmorSlots.main);
        }
        public static Armor EquipMainArmor(this Entity entity, NamespaceID id)
        {
            return entity.EquipArmorTo(VanillaArmorSlots.main, id);
        }
        #endregion

        #region 寻路
        public static bool MoveOrthogonally(this Entity entity, int targetGridIndex, float speed)
        {
            var level = entity.Level;
            var targetGridPosition = level.GetEntityGridPositionByIndex(targetGridIndex);
            var targetGridDistance = targetGridPosition - entity.Position;
            if (targetGridDistance.magnitude <= speed)
            {
                // 更新目标。
                entity.Position = targetGridPosition;
                return true;
            }
            else
            {
                entity.Position += targetGridDistance.normalized * speed;
            }
            return false;
        }
        public static LawnGrid? GetChaseTargetGrid(this Entity entity, Entity? target, Func<Entity, Vector2Int, bool> gridValidator)
        {
            var level = entity.Level;
            var lane = entity.GetLane();
            var column = entity.GetColumn();
            var x = entity.Position.x;

            Vector2Int currentGrid = new Vector2Int(column, lane);
            Vector2Int newTargetGridOffset = Vector2Int.zero;
            var possibleDirections = adjacentGridOffsets.Where(o => gridValidator(entity, currentGrid + o));
            if (possibleDirections.Count() <= 0)
                return entity.GetGrid();

            if (target.ExistsAndAlive() && possibleDirections.Count() > 0)
            {
                var targetLane = target.GetLane();
                float currentDistanceY = currentGrid.y - targetLane;
                float currentDistanceX = entity.Position.x - target.Position.x;
                var orderedDirections = possibleDirections
                    .OrderBy(o => Mathf.Abs(currentDistanceY + o.y) - Mathf.Abs(currentDistanceY))
                    .ThenBy(o => Mathf.Abs(currentDistanceX + o.x * level.GetGridWidth()) - Mathf.Abs(currentDistanceX));
                newTargetGridOffset = orderedDirections.FirstOrDefault();
            }
            else
            {
                var rng = entity.RNG;
                newTargetGridOffset = possibleDirections.Random(rng);
            }
            return level.GetGrid(currentGrid + newTargetGridOffset) ?? entity.GetGrid();
        }
        public static LawnGrid? GetChaseTargetGrid(this Entity entity, Entity? target)
        {
            return GetChaseTargetGrid(entity, target, (e, p) => e.Level.ValidateGridOutOfBounds(p));
        }
        public static LawnGrid? GetEvadeTargetGrid(this Entity entity, Entity target, Func<Entity, Vector2Int, bool> gridValidator)
        {
            var level = entity.Level;
            var lane = entity.GetLane();
            var column = entity.GetColumn();
            var x = entity.Position.x;

            Vector2Int currentGrid = new Vector2Int(column, lane);
            Vector2Int newTargetGridOffset = Vector2Int.zero;
            var possibleDirections = adjacentGridOffsets.Where(o => gridValidator(entity, currentGrid + o));
            if (possibleDirections.Count() <= 0)
                return entity.GetGrid();

            if (target.ExistsAndAlive() && possibleDirections.Count() > 0)
            {
                var targetLane = target.GetLane();
                float currentDistanceY = currentGrid.y - targetLane;
                float currentDistanceX = entity.Position.x - target.Position.x;
                var orderedDirections = possibleDirections
                    .OrderByDescending(o => Mathf.Abs(currentDistanceY + o.y) - Mathf.Abs(currentDistanceY))
                    .ThenByDescending(o => Mathf.Abs(currentDistanceX + o.x * level.GetGridWidth()) - Mathf.Abs(currentDistanceX));
                newTargetGridOffset = orderedDirections.FirstOrDefault();
            }
            else
            {
                var rng = entity.RNG;
                newTargetGridOffset = possibleDirections.Random(rng);
            }
            return level.GetGrid(currentGrid + newTargetGridOffset) ?? entity.GetGrid();
        }
        public static LawnGrid? GetEvadeTargetGrid(this Entity entity, Entity target)
        {
            return GetEvadeTargetGrid(entity, target, (e, p) => e.Level.ValidateGridOutOfBounds(p));
        }
        public static readonly Vector2Int[] adjacentGridOffsets = new Vector2Int[]
        {
            Vector2Int.down,
            Vector2Int.up,
            Vector2Int.right,
            Vector2Int.left
        };
        #endregion

        #region 蓝图掉落物
        public static bool IsBlueprintPickup(this Entity entity)
        {
            return entity != null && entity.IsEntityOf(VanillaPickupID.blueprintPickup);
        }
        #endregion

        #region 状态效果
        public static bool PreApplyStatusEffect(this Entity entity, BuffDefinition buff, ILevelSourceReference? source)
        {
            var param = new VanillaLevelCallbacks.PreApplyStatusEffectParams(entity, buff, source);
            var result = new CallbackResult(true);
            entity.Level.Triggers.RunCallbackWithResultFiltered(VanillaLevelCallbacks.PRE_APPLY_STATUS_EFFECT, param, result, buff.GetID());
            return result.GetValue<bool>();
        }
        public static void PostApplyStatusEffect(this Entity entity, Buff buff, ILevelSourceReference? source)
        {
            var param = new VanillaLevelCallbacks.PostApplyStatusEffectParams(entity, buff, source);
            entity.Level.Triggers.RunCallbackFiltered(VanillaLevelCallbacks.POST_APPLY_STATUS_EFFECT, param, buff.Definition.GetID());
        }
        public static bool PreRemoveStatusEffect(this Entity entity, BuffDefinition definition, ILevelSourceReference? source)
        {
            var param = new VanillaLevelCallbacks.PreRemoveStatusEffectParams(entity, definition, source);
            var result = new CallbackResult(true);
            entity.Level.Triggers.RunCallbackWithResultFiltered(VanillaLevelCallbacks.PRE_REMOVE_STATUS_EFFECT, param, result, definition.GetID());
            return result.GetValue<bool>();
        }
        public static void PostRemoveStatusEffect(this Entity entity, BuffDefinition definition, ILevelSourceReference? source)
        {
            var param = new VanillaLevelCallbacks.PostRemoveStatusEffectParams(entity, definition, source);
            entity.Level.Triggers.RunCallbackFiltered(VanillaLevelCallbacks.POST_REMOVE_STATUS_EFFECT, param, definition.GetID());
        }
        public static void InflictWither(this Entity entity, int time, ILevelSourceReference? source)
        {
            var buffDefinition = entity.Level.Content.GetBuffDefinition(VanillaBuffID.Entity.withered);
            if (buffDefinition == null || !PreApplyStatusEffect(entity, buffDefinition, source))
                return;
            Buff? buff = entity.GetFirstBuff(buffDefinition);
            if (buff == null)
            {
                buff = entity.AddBuff(buffDefinition);
            }
            buff.SetProperty(WitheredBuff.PROP_TIMEOUT, time);
            PostApplyStatusEffect(entity, buff, source);
        }

        public static void InflictWeakness(this Entity entity, int time, ILevelSourceReference? source)
        {
            var buffDefinition = entity.Level.Content.GetBuffDefinition(VanillaBuffID.Enemy.enemyWeakness);
            if (buffDefinition == null || !PreApplyStatusEffect(entity, buffDefinition, source))
                return;
            Buff? buff = entity.GetFirstBuff(buffDefinition);
            if (buff == null)
            {
                buff = entity.AddBuff(buffDefinition);
            }
            buff.SetProperty(EnemyWeaknessBuff.PROP_TIMEOUT, time);
            PostApplyStatusEffect(entity, buff, source);
        }

        public static void ShortCircuit(this Entity entity, int time, ILevelSourceReference? source)
        {
            var buffDefinition = entity.Level.Content.GetBuffDefinition(VanillaBuffID.Contraption.frankensteinShocked);
            if (buffDefinition == null || !PreApplyStatusEffect(entity, buffDefinition, source))
                return;
            var buff = entity.GetFirstBuff(buffDefinition);
            if (buff == null)
            {
                buff = entity.AddBuff(buffDefinition);
            }
            buff.SetProperty(FrankensteinShockedBuff.PROP_TIMEOUT, time);
            PostApplyStatusEffect(entity, buff, source);
        }

        public static void InflictSlow(this Entity entity, int time, ILevelSourceReference? source)
        {
            var buffDefinition = entity.Level.Content.GetBuffDefinition(VanillaBuffID.Enemy.slow);
            if (buffDefinition == null || !PreApplyStatusEffect(entity, buffDefinition, source))
                return;
            var buff = entity.GetFirstBuff(buffDefinition);
            if (buff == null)
            {
                entity.PlaySound(VanillaSoundID.freeze);
                buff = entity.AddBuff(buffDefinition);
            }
            SlowBuff.SetTimeout(buff, time);
            PostApplyStatusEffect(entity, buff, source);
        }

        public static void Unfreeze(this Entity entity, ILevelSourceReference? source)
        {
            var buffDefinition = entity.Level.Content.GetBuffDefinition(VanillaBuffID.Enemy.slow);
            if (buffDefinition == null || !PreRemoveStatusEffect(entity, buffDefinition, source))
                return;
            entity.RemoveBuffs(buffDefinition);
            PostRemoveStatusEffect(entity, buffDefinition, source);
        }

        public static void InflictRegenerationBuff(this Entity entity, float Heal, int time, ILevelSourceReference? source)
        {
            var buffDefinition = entity.Level.Content.GetBuffDefinition(VanillaBuffID.Entity.Regeneration);
            if (buffDefinition == null || !PreRemoveStatusEffect(entity, buffDefinition, source))
                return;
            Buff? buff = entity.GetFirstBuff(buffDefinition);
            if (buff == null)
            {
                buff = entity.AddBuff(buffDefinition);
            }
            buff.SetProperty(RegenerationBuff.PROP_HEAL_AMOUNT, Heal);
            buff.SetProperty(RegenerationBuff.PROP_TIMEOUT, time);
        }

        public static void InflictCorropoisonBuff(this Entity entity, float damage, int time, ILevelSourceReference? source)
        {
            var buffDefinition = entity.Level.Content.GetBuffDefinition(VanillaBuffID.Entity.Corropoison);
            if (buffDefinition == null || !PreRemoveStatusEffect(entity, buffDefinition, source))
                return;
            Buff? buff = entity.GetFirstBuff(buffDefinition);
            if (buff == null)
            {
                buff = entity.AddBuff(buffDefinition);
            }
            buff.SetProperty(CorropoisonBuff.PROP_DAMAGE_AMOUNT, damage);
            buff.SetProperty(CorropoisonBuff.PROP_TIMEOUT, time);
        }
        #region 魅惑
        public static void CharmPermanent(this Entity entity, int faction, ILevelSourceReference? source)
        {
            var buffDefinition = entity.Level.Content.GetBuffDefinition(VanillaBuffID.Entity.charm);
            if (buffDefinition == null || !PreApplyStatusEffect(entity, buffDefinition, source))
                return;
            var buff = entity.GetFirstBuff(buffDefinition);
            if (buff == null)
            {
                buff = entity.AddBuff(buffDefinition);
            }
            CharmBuff.SetPermanent(buff, faction);
            buff.Update();
            PostApplyStatusEffect(entity, buff, source);
        }

        public static void CharmWithController(this Entity entity, Entity controller, ILevelSourceReference? source)
        {
            var buffDefinition = entity.Level.Content.GetBuffDefinition(VanillaBuffID.Entity.charm);
            if (buffDefinition == null || !PreApplyStatusEffect(entity, buffDefinition, source))
                return;
            var buff = entity.GetFirstBuff(buffDefinition);
            if (buff == null)
            {
                buff = entity.AddBuff(buffDefinition);
            }
            CharmBuff.SetController(buff, controller);
            buff.Update();
            PostApplyStatusEffect(entity, buff, source);
        }
        public static void RemoveCharm(this Entity entity, ILevelSourceReference? source)
        {
            var buffDefinition = entity.Level.Content.GetBuffDefinition(VanillaBuffID.Entity.charm);
            if (buffDefinition == null || !PreRemoveStatusEffect(entity, buffDefinition, source))
                return;
            entity.RemoveBuffs(buffDefinition);
            PostRemoveStatusEffect(entity, buffDefinition, source);
        }
        public static bool IsCharmed(this Entity entity)
        {
            return entity.HasBuff<CharmBuff>();
        }
        #endregion

        #endregion

        #region 强力冲击
        public static void ApplyStrongImpact(this Entity target)
        {
            var passenger = target.GetRideablePassenger();
            if (passenger != null)
            {
                passenger.Stun(90);
                target.GetOffHorse();
            }
        }
        #endregion

        #region 移除性死亡
        public static void RemoveDie(this Entity entity)
        {
            entity.RemoveDie((ILevelSourceReference?)null);
        }
        public static void RemoveDie(this Entity entity, Entity? source)
        {
            entity.RemoveDie(source != null ? new EntitySourceReference(source) : null);
        }
        public static void RemoveDie(this Entity entity, ILevelSourceReference? source)
        {
            var effects = new DamageEffectList(VanillaDamageEffects.REMOVE_ON_DEATH, VanillaDamageEffects.NO_DEATH_TRIGGER);
            entity.Die(effects, source);
        }
        #endregion
        public static float GetRealGroundLimitY(this Entity entity)
        {
            return entity.GetGroundLimitOffset() + entity.GetGroundY();
        }
        public static SpawnParams GetSpawnParams(this Entity entity)
        {
            var param = new SpawnParams();
            param.SetProperty(EngineEntityProps.FACTION, entity.GetFaction());
            return param;
        }
        public static Entity? SpawnWithParams(this Entity entity, NamespaceID id, Vector3 pos)
        {
            var param = entity.GetSpawnParams();
            return entity.Spawn(id, pos, param);
        }

        private const string PROP_REGION = "entities";
        [EntityPropertyRegistry(PROP_REGION)]
        public static readonly VanillaEntityPropertyMeta<EntityID> PROP_SHINE_RING = new VanillaEntityPropertyMeta<EntityID>("LightShineRing");
    }
}
