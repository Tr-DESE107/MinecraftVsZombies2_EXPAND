#nullable enable // autogenerated

using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using MVZ2.IO;
using MVZ2Logic;
using PVZEngine;
using UnityEngine;

namespace MVZ2.Metas
{
    public class TalkCharacterMetaList
    {
        public List<TalkCharacterMeta> metas = new List<TalkCharacterMeta>();
        public static TalkCharacterMetaList FromXmlNode(XmlNode node, string defaultNsp)
        {
            var list = new TalkCharacterMetaList();
            var metaChildNodes = node.ChildNodes;
            for (int i = 0; i < metaChildNodes.Count; i++)
            {
                var child = metaChildNodes[i];
                var meta = TalkCharacterMeta.FromXmlNode(child, defaultNsp);
                if (meta != null)
                    list.metas.Add(meta);
            }
            return list;
        }
    }

    public class TalkCharacterMeta
    {
        public string id;
        public string name = string.Empty;
        public NamespaceID? unlockCondition;
        public List<TalkCharacterVariant> variants = new List<TalkCharacterVariant>();

        public TalkCharacterMeta(string id)
        {
            this.id = id;
        }

        public TalkCharacterVariant GetVariant(NamespaceID id)
        {
            return variants.FirstOrDefault(v => v.id == id);
        }
        public static TalkCharacterMeta? FromXmlNode(XmlNode node, string defaultNsp)
        {
            var id = node.GetAttribute("id");
            if (string.IsNullOrEmpty(id))
            {
                Log.LogError($"The {nameof(id)} of a {nameof(TalkCharacterMeta)} is invalid.");
                return null;
            }
            var meta = new TalkCharacterMeta(id);
            meta.name = node.GetAttribute("name") ?? string.Empty;
            meta.unlockCondition = node.GetAttributeNamespaceID("unlock", defaultNsp);

            var variantTemplates = new List<TalkCharacterVariantTemplate>();
            var variantChildNodes = node.ChildNodes;
            for (int i = 0; i < variantChildNodes.Count; i++)
            {
                var child = variantChildNodes[i];
                if (child.Name == "variant")
                {
                    var template = TalkCharacterVariantTemplate.FromXmlNode(child, defaultNsp);
                    if (template != null)
                        variantTemplates.Add(template);
                }
            }
            meta.variants.AddRange(variantTemplates.Select(t => t.ToVariant(variantTemplates)));
            return meta;
        }
    }

    public class TalkCharacterVariantTemplate
    {
        public NamespaceID id;
        public NamespaceID? parent;
        public XMLConditionList? unlock;
        public int? width;
        public int? height;
        public float? pivotX;
        public float? pivotY;
        public float? extendLeft;
        public float? extendRight;
        public List<TalkCharacterLayer> layers = new List<TalkCharacterLayer>();

        public TalkCharacterVariantTemplate(NamespaceID id)
        {
            this.id = id;
        }

        public static TalkCharacterVariantTemplate? FromXmlNode(XmlNode node, string defaultNsp)
        {
            var id = node.GetAttributeNamespaceID("id", defaultNsp);
            if (!NamespaceID.IsValid(id))
            {
                Log.LogError($"The {nameof(id)} of a {nameof(TalkCharacterVariantTemplate)} is invalid.");
                return null;
            }
            var variant = new TalkCharacterVariantTemplate(id);
            variant.parent = node.GetAttributeNamespaceID("parent", defaultNsp);

            variant.width = node.GetAttributeInt("width");
            variant.height = node.GetAttributeInt("height");
            variant.extendLeft = node.GetAttributeFloat("extendLeft");
            variant.extendRight = node.GetAttributeFloat("extendRight");
            variant.pivotX = node.GetAttributeFloat("pivotX");
            variant.pivotY = node.GetAttributeFloat("pivotY");

            variant.unlock = node.GetUnlockConditionsOrObsolete("unlock", "unlock", defaultNsp);

            var variantChildNodes = node.ChildNodes;
            for (int i = 0; i < variantChildNodes.Count; i++)
            {
                var child = variantChildNodes[i];
                if (child.Name == "layer")
                {
                    variant.layers.Add(TalkCharacterLayer.FromXmlNode(child, defaultNsp));
                }
            }
            return variant;
        }
        public TalkCharacterVariant ToVariant(IEnumerable<TalkCharacterVariantTemplate> templates)
        {
            var result = new TalkCharacterVariant(id);
            var visited = new Stack<TalkCharacterVariantTemplate>();
            GetCharacterVariantProperties(templates, result, visited);
            result.unlock = unlock;
            return result;
        }
        private void GetCharacterVariantProperties(IEnumerable<TalkCharacterVariantTemplate> templatePool, TalkCharacterVariant result, Stack<TalkCharacterVariantTemplate> visited)
        {
            if (visited.Contains(this))
                throw new InvalidOperationException($"A recursion exception has been occured while loading talk character {id} from talkcharacter.xml, maybe a cycle parent reference is present.");
            visited.Push(this);
            var parentID = parent;
            if (NamespaceID.IsValid(parentID))
            {
                var parent = templatePool.FirstOrDefault(t => t.id == parentID);
                if (parent != null)
                {
                    parent.GetCharacterVariantProperties(templatePool, result, visited);
                }
            }
            visited.Pop();
            result.pivotX = pivotX ?? result.pivotX;
            result.pivotY = pivotY ?? result.pivotY;
            result.width = width ?? result.width;
            result.height = height ?? result.height;
            result.widthExtend = new Vector2(extendLeft ?? result.widthExtend.x, extendRight ?? result.widthExtend.y);
            result.layers.AddRange(layers);
        }
    }
    public class TalkCharacterVariant
    {
        public NamespaceID id;
        public XMLConditionList? unlock;
        public int width;
        public int height;
        public float pivotX = 0.5f;
        public float pivotY = 0.5f;
        public Vector2 widthExtend;
        public List<TalkCharacterLayer> layers = new List<TalkCharacterLayer>();

        public TalkCharacterVariant(NamespaceID id)
        {
            this.id = id;
        }
    }

    public class TalkCharacterLayer
    {
        public SpriteReference? sprite;
        public int positionX;
        public int positionY;
        public static TalkCharacterLayer FromXmlNode(XmlNode node, string defaultNsp)
        {
            var layer = new TalkCharacterLayer();
            layer.sprite = node.GetAttributeSpriteReference("sprite", defaultNsp);
            layer.positionX = node.GetAttributeInt("positionX") ?? 0;
            layer.positionY = node.GetAttributeInt("positionY") ?? 0;
            return layer;
        }
    }
}
