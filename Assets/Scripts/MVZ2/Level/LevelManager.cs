#nullable enable // autogenerated

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using MongoDB.Bson.IO;
using MVZ2.IO;
using MVZ2.Logic.Level;
using MVZ2.Managers;
using MVZ2.Scenes;
using MVZ2.Vanilla;
using MVZ2.Vanilla.Level;
using MVZ2Logic;
using MVZ2Logic.Games;
using PVZEngine;
using PVZEngine.Level;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace MVZ2.Level
{
    public class LevelManager : MonoBehaviour, IGlobalLevel
    {
        internal void SetLevelController(LevelController controller)
        {
            this.controller = controller;
        }
        public LevelController GetLevelController()
        {
            return controller;
        }
        public LevelEngine GetLevel()
        {
            if (!controller)
                return null;
            return controller.GetEngine();
        }
        public bool IsInLevel()
        {
            return GetLevel() != null;
        }
        public void InitLevel(NamespaceID areaID, NamespaceID stageID, float beginningDelay = 0, LevelExitTarget exitTarget = LevelExitTarget.MapOrMainmenu)
        {
            if (!controller)
                return;
            Main.SaveManager.SaveToFile(); // 关卡开始时保存游戏
            controller.SetStartStage(areaID, stageID);
            if (HasLevelState(stageID))
            {
                LoadLevel(areaID, stageID);
            }
            else
            {
                controller.InitLevel(Main.Game, areaID, stageID);
                controller.StartLevelIntro(beginningDelay);
            }
            controller.SetExitTarget(exitTarget);
        }
        #region 关卡存读
        public void SaveLevel()
        {
            if (!controller)
                return;
            var stageID = controller.GetStartStageID();
            var path = GetLevelStatePath(stageID);
            FileHelper.ValidateDirectory(path);


            // 打开文件流
            using var stream = Main.FileManager.OpenFileWrite(path);
            using var writer = new StreamWriter(stream);

            // 写入文件首信息
            var header = controller.SaveGameHeader();
            var headerJson = header.ToBson();
            writer.WriteLine(headerJson);

            // 写入文件内容
            var content = controller.SaveGame();
            var contentJson = content.ToBson();
            writer.WriteLine(contentJson);

            UpdateCurrentEndlessFlags(stageID, controller.GetCurrentFlag());
        }
        public void LoadLevel(NamespaceID areaID, NamespaceID stageID)
        {
            if (!controller)
                return;
            if (!HasLevelState(stageID))
                return;
            try
            {
                controller.SetActive(true);
                var path = GetLevelStatePath(stageID);

                // 打开文件流
                using var stream = Main.FileManager.OpenFileRead(path);
                using var streamReader = new StreamReader(stream);
                using var jsonReader = new JsonReader(streamReader);

                // 读取首行数据
                var header = SerializeHelper.ReadBson<SerializableLevelControllerHeader>(jsonReader);

                // 验证首行数据
                var validate = controller.ValidateGameStateHeader(header);
                if (!validate)
                    return;

                // 读取内容
                var content = SerializeHelper.ReadBson<SerializableLevelController>(jsonReader);

                bool success = controller.LoadGame(content, Main.Game, areaID, stageID);
                if (!success)
                    return;
                UpdateCurrentEndlessFlags(stageID, controller.GetCurrentFlag());
            }
            catch (Exception e)
            {
                controller.ShowLevelErrorLoadingDialog(e);
            }
        }
        public bool HasLevelState(NamespaceID stageID)
        {
            var path = GetLevelStatePath(stageID);
            return File.Exists(path);
        }
        public void RemoveLevelState(NamespaceID stageID)
        {
            var path = GetLevelStatePath(stageID);
            if (File.Exists(path))
            {
                File.Delete(path);
            }
            UpdateCurrentEndlessFlags(stageID, 0);
        }
        public string GetLevelStatePath(NamespaceID stageID)
        {
            var userIndex = Main.SaveManager.GetCurrentUserIndex();
            var dir = Main.SaveManager.GetUserModSaveDataDirectory(userIndex, stageID.SpaceName);
            return Path.Combine(dir, "level", $"{stageID.Path}.lvl");
        }
        public LevelDataIdentifierList GetLevelStateIdentifierList()
        {
            var mods = Main.ModManager.GetAllModInfos();
            return new LevelDataIdentifierList(mods.Select(m => new LevelDataIdentifier(m.Namespace, m.LevelDataVersion)));
        }
        public string GetStageName(NamespaceID stageID)
        {
            var meta = Main.Game.GetStageDefinition(stageID);
            if (meta == null)
                return Main.LanguageManager._p(VanillaStrings.CONTEXT_LEVEL_NAME, VanillaStrings.LEVEL_NAME_UNKNOWN);
            var levelName = Main.LanguageManager._p(VanillaStrings.CONTEXT_LEVEL_NAME, meta.GetLevelName());
            var dayNumber = meta.GetDayNumber();
            if (dayNumber > 0)
            {
                levelName = Main.LanguageManager._pn(VanillaStrings.CONTEXT_LEVEL_NAME, VanillaStrings.LEVEL_NAME_DAY_TEMPLATE, dayNumber, levelName, dayNumber);
            }
            return levelName;
        }
        public string GetStageName(LevelEngine level)
        {
            string name = level?.GetLevelName();
            if (string.IsNullOrEmpty(name))
                name = VanillaStrings.LEVEL_NAME_UNKNOWN;
            var levelName = Main.LanguageManager._p(VanillaStrings.CONTEXT_LEVEL_NAME, name);
            int dayNumber = level.GetDayNumber();
            if (dayNumber > 0)
            {
                levelName = Main.LanguageManager._pn(VanillaStrings.CONTEXT_LEVEL_NAME, VanillaStrings.LEVEL_NAME_DAY_TEMPLATE, dayNumber, levelName, dayNumber);
            }
            if (level.IsEndless() && level.CurrentFlag > 0)
            {
                levelName = Main.LanguageManager._pn(VanillaStrings.CONTEXT_LEVEL_NAME, VanillaStrings.LEVEL_NAME_ENDLESS_FLAGS_TEMPLATE, level.CurrentFlag, levelName, level.CurrentFlag);
            }
            return levelName;
        }
        #endregion
        public Vector3 LawnToTrans(Vector3 pos)
        {
            if (controller)
            {
                return controller.LawnToTrans(pos);
            }
            pos *= LawnToTransScale;
            return new Vector3(pos.x, pos.z + pos.y, pos.z);
        }
        public Vector3 TransToLawn(Vector3 pos)
        {
            if (controller)
            {
                return controller.TransToLawn(pos);
            }
            Vector3 vector = new Vector3(pos.x, pos.y - pos.z, pos.z);
            vector *= TransToLawnScale;
            return vector;
        }
        public async Task GotoLevelSceneAsync()
        {
            var sceneName = "Level";
            var oldScene = Scene.GetSceneInstance(sceneName);
            var oldController = controller;

            var newScene = (await Scene.LoadSceneAsync(sceneName, LoadSceneMode.Additive));
            foreach (var go in newScene.Scene.GetRootGameObjects())
            {
                var ctrl = go.GetComponent<LevelController>();
                if (ctrl)
                {
                    SetLevelController(ctrl);
                    break;
                }
            }
            if (controller)
            {
                controller.SetActive(false);
            }
            if (oldScene.Scene.IsValid())
            {
                await Scene.UnloadSceneAsync(oldScene);
            }
        }
        public async Task ExitLevelSceneAsync()
        {
            var sceneName = "Level";
            if (!Scene.IsSceneLoaded(sceneName))
                return;
            await Scene.UnloadSceneAsync(sceneName);
            SetLevelController(null);
        }
        private void UpdateCurrentEndlessFlags(NamespaceID stageID, int flags)
        {
            var stageDef = Main.Game.GetStageDefinition(stageID);
            if (stageDef != null && stageDef.IsEndless())
            {
                Main.SaveManager.SetCurrentEndlessFlag(stageID, flags);
            }
        }
        public const int CURRENT_DATA_VERSION = 3;
        public float LawnToTransScale => 1 / transToLawnScale;
        public float TransToLawnScale => transToLawnScale;
        public MainManager Main => main;
        public SceneLoadingManager Scene => main.SceneManager;
        [SerializeField]
        private MainManager main;
        [SerializeField]
        private float transToLawnScale = 100;
        private LevelController controller;
    }
    public struct LevelDataIdentifierCompareResult
    {
        public LevelDataIdentifierPair[] versionMismatches;
        public LevelDataIdentifier[] missingMismatches;
        public LevelDataIdentifier[] additionalMismatches;
        public bool valid;
    }
    public struct LevelDataIdentifierPair
    {
        public LevelDataIdentifier lhs;
        public LevelDataIdentifier rhs;
    }
    [Serializable]
    public class LevelDataIdentifierList
    {
        public LevelDataIdentifierList(IEnumerable<LevelDataIdentifier> identifiers)
        {
            this.identifiers.AddRange(identifiers);
        }
        public LevelDataIdentifierCompareResult Compare(LevelDataIdentifierList other)
        {
            if (other == null)
            {
                return new LevelDataIdentifierCompareResult()
                {
                    valid = false,
                    versionMismatches = Array.Empty<LevelDataIdentifierPair>(),
                    missingMismatches = Array.Empty<LevelDataIdentifier>(),
                    additionalMismatches = identifiers.ToArray(),
                };
            }

            var versionMismatches = new List<LevelDataIdentifierPair>();
            var missingMismatches = new List<LevelDataIdentifier>();
            var additionalMismatches = new List<LevelDataIdentifier>();
            foreach (var i1 in identifiers)
            {
                bool nameMatches = false;
                foreach (var i2 in other.identifiers)
                {
                    if (i1.spaceName == i2.spaceName)
                    {
                        nameMatches = true;
                        if (i1.dataVersion != i2.dataVersion)
                        {
                            versionMismatches.Add(new LevelDataIdentifierPair() { lhs = i1, rhs = i2 });
                        }
                    }
                }
                if (!nameMatches)
                {
                    additionalMismatches.Add(i1);
                }
            }
            foreach (var i1 in other.identifiers)
            {
                bool nameMatches = false;
                foreach (var i2 in identifiers)
                {
                    if (i1.spaceName == i2.spaceName)
                    {
                        nameMatches = true;
                        break;
                    }
                }
                if (!nameMatches)
                {
                    missingMismatches.Add(i1);
                }
            }
            bool valid = versionMismatches.Count + missingMismatches.Count + additionalMismatches.Count == 0;
            return new LevelDataIdentifierCompareResult()
            {
                valid = valid,
                versionMismatches = versionMismatches.ToArray(),
                missingMismatches = missingMismatches.ToArray(),
                additionalMismatches = additionalMismatches.ToArray()
            };
        }
        public override int GetHashCode()
        {
            var hash = 0;
            foreach (var id in identifiers)
            {
                hash = hash * 31 + id.GetHashCode();
            }
            return hash;
        }
        public List<LevelDataIdentifier> identifiers = new List<LevelDataIdentifier>();
    }
    [Serializable]
    public class LevelDataIdentifier
    {
        public LevelDataIdentifier(string name, int version)
        {
            spaceName = name;
            dataVersion = version;
        }
        public string spaceName;
        public int dataVersion;

        public override bool Equals(object obj)
        {
            return obj is LevelDataIdentifier identifier &&
                   spaceName == identifier.spaceName &&
                   dataVersion == identifier.dataVersion;
        }

        public override int GetHashCode()
        {
            var hash = spaceName.GetHashCode();
            hash = hash * 31 + dataVersion.GetHashCode();
            return hash;
        }

        public static bool operator ==(LevelDataIdentifier left, LevelDataIdentifier right)
        {
            return EqualityComparer<LevelDataIdentifier>.Default.Equals(left, right);
        }

        public static bool operator !=(LevelDataIdentifier left, LevelDataIdentifier right)
        {
            return !(left == right);
        }
    }
}
