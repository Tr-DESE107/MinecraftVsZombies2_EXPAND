#nullable enable // autogenerated

using System;
using MVZ2.HeldItems;
using MVZ2.Vanilla;
using MVZ2.Vanilla.HeldItems;
using MVZ2Logic.Games;
using MVZ2Logic.HeldItems;
using MVZ2Logic.Level;
using MVZ2Logic.Level.Components;
using PVZEngine;
using PVZEngine.Base;
using PVZEngine.Level;
using PVZEngine.Models;

namespace MVZ2.Level.Components
{
    public partial class HeldItemComponent : MVZ2Component, IHeldItemComponent
    {
        public HeldItemComponent(LevelEngine level, LevelController controller) : base(level, componentID, controller)
        {
            info = new HeldItemData(BuiltinHeldTypes.none);
        }
        public override void PostAttach(LevelEngine level)
        {
            base.PostAttach(level);
            ResetHeldItem();
        }
        public override void Update()
        {
            base.Update();
            var definition = GetHeldItemDefinition();
            if (definition != null)
            {
                definition.Update(Level, Data);
            }
        }
        public bool IsHoldingItem()
        {
            var type = Data.Type;
            return NamespaceID.IsValid(type) && type != BuiltinHeldTypes.none;
        }
        public void SetHeldItem(IHeldItemBuilder builder)
        {
            if (IsHoldingItem() && info.Priority > builder.Priority)
                return;
            var definition = Level.Content.GetHeldItemDefinition(builder.Type);
            if (definition == null)
            {
                var exception = new MissingDefinitionException($"Trying to set a missing held item definition {builder.Type}.");
                Log.LogException(exception);
                return;
            }

            var before = GetHeldItemDefinition();
            before?.End(Level, Data);

            info.Build(builder);
            Controller.SetHeldItemUI(info);

            definition.Begin(Level, Data);
            Controller.UpdateEntityHeldTargetColliders(definition.GetHeldTargetMask(Level));
        }
        public IModelInterface? GetHeldItemModelInterface()
        {
            return Controller.GetHeldItemModelInterface();
        }
        public void ResetHeldItem()
        {
            var type = BuiltinHeldTypes.none;
            var definition = Level.Content.GetHeldItemDefinition(type);
            if (definition == null)
            {
                var exception = new MissingDefinitionException($"Trying to set a missing held item definition {type}.");
                Log.LogException(exception);
                return;
            }
            var before = GetHeldItemDefinition();
            before?.End(Level, Data);

            var builder = new HeldItemBuilder(type, 0);
            info.Build(builder);
            Controller.SetHeldItemUI(info);

            Controller.UpdateEntityHeldTargetColliders(definition.GetHeldTargetMask(Level));
        }
        public bool CancelHeldItem()
        {
            if (!IsHoldingItem() || info.CannotCancel())
                return false;
            ResetHeldItem();
            return true;
        }
        private HeldItemDefinition? GetHeldItemDefinition()
        {
            return Data.GetDefinition(Level);
        }
        public IHeldItemData Data => info;
        private HeldItemData info;
        public static readonly NamespaceID componentID = new NamespaceID(VanillaMod.spaceName, "heldItem");
    }
    [Serializable]
    public class EmptySerializableLevelComponent : ISerializableLevelComponent
    {
    }
}