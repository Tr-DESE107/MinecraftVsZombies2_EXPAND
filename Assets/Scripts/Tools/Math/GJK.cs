#nullable enable // autogenerated

using System.Collections.Generic;
using UnityEngine;

namespace Tools.Mathematics
{
    // GJK算法实现
    public static class GJK
    {
        private const int MAX_ITERATIONS = 32;

        // GJK支持函数（Minkowski差）
        private static Vector3 Support(IConvexShape shapeA, IConvexShape shapeB, Vector3 direction)
        {
            Vector3 pointA = shapeA.GetFarthestPointInDirection(direction);
            Vector3 pointB = shapeB.GetFarthestPointInDirection(-direction);
            return pointA - pointB;
        }

        public static bool CheckCollision(IConvexShape a, IConvexShape b)
        {
            Vector3 dir = b.GetCenter() - a.GetCenter();
            if (dir.sqrMagnitude < Mathf.Epsilon)
                dir = Vector3.right;

            List<Vector3> simplex = new List<Vector3>(4);

            Vector3 A = Support(a, b, dir);
            simplex.Add(A);
            dir = -A;

            for (int i = 0; i < MAX_ITERATIONS; i++)
            {
                if (dir.sqrMagnitude < Mathf.Epsilon)
                    dir = -simplex[^1];

                A = Support(a, b, dir);

                // 推进失败 → 一定不相交
                if (Vector3.Dot(A, dir) <= Mathf.Epsilon)
                    return false;

                simplex.Add(A);

                if (HandleSimplex(simplex, ref dir))
                    return true;
            }

            // 正常情况下永远不会走到这里
            return false;
        }

        static bool HandleSimplex(List<Vector3> s, ref Vector3 dir)
        {
            switch (s.Count)
            {
                case 2: return Line(s, ref dir);
                case 3: return Triangle(s, ref dir);
                case 4: return Tetrahedron(s, ref dir);
            }
            return false;
        }

        static bool Line(List<Vector3> s, ref Vector3 dir)
        {
            Vector3 A = s[^1];
            Vector3 B = s[^2];
            Vector3 AB = B - A;
            Vector3 AO = -A;

            if (Vector3.Dot(AB, AO) > 0)
            {
                dir = Vector3.Cross(Vector3.Cross(AB, AO), AB);
            }
            else
            {
                s.Clear();
                s.Add(A);
                dir = AO;
            }

            return false;
        }

        static bool Triangle(List<Vector3> s, ref Vector3 dir)
        {
            Vector3 A = s[^1];
            Vector3 B = s[^2];
            Vector3 C = s[^3];

            Vector3 AB = B - A;
            Vector3 AC = C - A;
            Vector3 AO = -A;

            Vector3 ABC = Vector3.Cross(AB, AC);

            // AC side
            if (Vector3.Dot(Vector3.Cross(ABC, AC), AO) > 0)
            {
                if (Vector3.Dot(AC, AO) > 0)
                {
                    s.Clear();
                    s.Add(C);
                    s.Add(A);
                    dir = Vector3.Cross(Vector3.Cross(AC, AO), AC);
                }
                else
                {
                    s.Clear();
                    s.Add(B);
                    s.Add(A);
                    return Line(s, ref dir);
                }
                return false;
            }

            // AB side
            if (Vector3.Dot(Vector3.Cross(AB, ABC), AO) > 0)
            {
                s.Clear();
                s.Add(B);
                s.Add(A);
                return Line(s, ref dir);
            }

            // Above or below triangle
            if (Vector3.Dot(ABC, AO) > 0)
            {
                dir = ABC;
            }
            else
            {
                s.Clear();
                s.Add(B);
                s.Add(C);
                s.Add(A);
                dir = -ABC;
            }

            return false;
        }

        static bool Tetrahedron(List<Vector3> s, ref Vector3 dir)
        {
            Vector3 A = s[^1];
            Vector3 B = s[^2];
            Vector3 C = s[^3];
            Vector3 D = s[^4];

            Vector3 AO = -A;

            Vector3 AB = B - A;
            Vector3 AC = C - A;
            Vector3 AD = D - A;

            Vector3 ABC = Vector3.Cross(AB, AC);
            Vector3 ACD = Vector3.Cross(AC, AD);
            Vector3 ADB = Vector3.Cross(AD, AB);

            if (Vector3.Dot(ABC, AO) > 0)
            {
                s.Clear(); s.Add(C); s.Add(B); s.Add(A);
                dir = ABC;
                return false;
            }

            if (Vector3.Dot(ACD, AO) > 0)
            {
                s.Clear(); s.Add(D); s.Add(C); s.Add(A);
                dir = ACD;
                return false;
            }

            if (Vector3.Dot(ADB, AO) > 0)
            {
                s.Clear(); s.Add(B); s.Add(D); s.Add(A);
                dir = ADB;
                return false;
            }

            // 原点在四面体内部
            return true;
        }
    }
}